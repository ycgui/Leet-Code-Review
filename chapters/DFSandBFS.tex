\chapter{DFS and BFS}
\section{Subset (M)}
Given a set of distinct integers, nums, return all possible subsets.\\
Note: The solution set must not contain duplicate subsets.\\
For example,
If nums = [1,2,3], a solution is:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]\\

\begin{lstlisting}
class Solution(object):
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        nums.sort()
        out, res = [], []
        idx = 0
        self.dfs(nums, idx, out, res)
        return res
    def dfs(self, nums, idx, out, res):
        # always add out to res in recursion to get all subsets
        res.append(list(out))
        for i in range(idx, len(nums)):
            out.append(nums[i])
            self.dfs(nums, i + 1, out, res)
            out.pop()
\end{lstlisting}

\begin{lstlisting}
// 1. Recursive
class Solution {
public:
    vector<vector<int>> subsets(vector<int> &nums) {
        vector<vector<int>> res;
        vector<int> out;
        sort(nums.begin(), nums.end());
        getSubsets(nums, res, out, 0);
        return res;
    }
    void getSubsets(vector<int> &nums, vector<vector<int>> &res, vector<int> &out, int pos) {
        res.push_back(out);
        for (int i = pos; i < nums.size(); ++i) {
            out.push_back(nums[i]);
            getSubsets(nums, res, out, i+1);
            out.pop_back();
        }
    }
};

// 2. Iterative
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res(1, vector<int>());
        for (int i = 0; i < nums.size(); ++i) {
            int n = res.size();
            for (int j = 0; j < n; ++j) {
                res.push_back(res[j]);
                res.back().push_back(nums[i]);
            }
        }
        return res;
    }
};
\end{lstlisting}


\section{Subset II (M)}
Given a collection of integers that might contain duplicates, nums, return all possible subsets.\\
Note: The solution set must not contain duplicate subsets.\\
For example,
If nums = [1,2,2], a solution is:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]\\

\begin{lstlisting}
class Solution(object):
    def subsetsWithDup(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        nums.sort()
        out, res = [], []
        idx = 0
        self.dfs(nums, idx, out, res)
        return res
    def dfs(self, nums, idx, out, res):
        # always add out to res in recursion to get all subsets
        res.append(list(out))
        for i in range(idx, len(nums)):
            # skip duplicate
            if i > idx and nums[i] == nums[i-1]: continue
            out.append(nums[i])
            self.dfs(nums, i+1, out, res)
            out.pop()
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        vector<int> out;
        getSubsets(nums, res, out, 0);
        return res;
    }
    void getSubsets(vector<int>& nums, vector<vector<int>>& res, vector<int>& out, int pos) {
        res.push_back(out);
        for (int i = pos; i < nums.size(); ++i) {
            if (i == pos || nums[i] != nums[i-1]) {
                out.push_back(nums[i]);
                getSubsets(nums, res, out, i+1);
                out.pop_back();
            }
        }
    }
};
\end{lstlisting}


\section{Permutations (M)}
Given a collection of distinct numbers, return all possible permutations. \\

For example,
[1,2,3] have the following permutations: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]\\

\begin{lstlisting}
class Solution(object):
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        level = 0
        n = len(nums)
        out, res = [], []
        visited = [0] * n
        self.dfs(nums, level, visited, out, res)
        return res
    def dfs(self, nums, level, visited, out, res):
        if level == len(nums):
            res.append(list(out))
        # DFS checks the whole list, skipping the visited one
        # For combination, DFS starts with the level idx, 
        # and it does not check the whole list to avoid duplication
        for i in range(len(nums)):
            if visited[i] == 1: continue
            visited[i] = 1
            out.append(nums[i])
            self.dfs(nums, level+1, visited, out, res)
            out.pop()
            visited[i] = 0
\end{lstlisting}

\begin{lstlisting}
// 1. Use visited vector
class Solution {
public:
    vector<vector<int> > permute(vector<int> &num) {
        vector<vector<int>> res;
        vector<int> out;
        vector<int> visited(num.size(), 0); // save visited states
        permuteDFS(num, 0, visited, out, res);
        return res;
    }
    void permuteDFS(vector<int> &num, int level, vector<int> &visited, vector<int> &out, vector<vector<int>> &res) {
        if (level == num.size()) res.push_back(out);
        else {
            for (int i = 0; i < num.size(); ++i) {
                if (visited[i] == 0) {
                    visited[i] = 1;
                    out.push_back(num[i]);
                    permuteDFS(num, level + 1, visited, out, res);
                    out.pop_back();
                    visited[i] = 0;
                }
            }
        }
    }
};

// 2. Use swap function
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
        permuteDFS(nums, 0, nums.size()-1, res);
        return res;
    }
    void permuteDFS(vector<int>& nums, int start, int end, vector<vector<int>> &res) {
        if (start > end) {
            res.push_back(nums);
            return;
        }
        for (int i = start; i <= end; ++i) {
            swap(nums[start], nums[i]);
            permuteDFS(nums, start+1, end, res);
            swap(nums[start], nums[i]);
        }
    }
};
\end{lstlisting}


\section{Permutations II (M)}
Given a collection of numbers that might contain duplicates, return all possible unique permutations.\\

For example, [1,1,2] have the following unique permutations:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
] \\

\begin{lstlisting}
class Solution(object):
    def permuteUnique(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        level = 0
        out, res = [], []
        visited = [0] * len(nums) 
        nums.sort()
        self.dfs(nums, level, visited, out, res)
        return res
    def dfs(self, nums, level, visited, out, res):
        if level == len(nums):
            res.append(list(out))
            return
        for i in range(len(nums)):
            if visited[i] == 1: continue
            # duplicated permuation needs to be skipped if the new permutation
            # starts with a number that is the same as the last permutation
            if i > 0 and nums[i] == nums[i-1] and visited[i-1] == 0: continue
            visited[i] = 1
            out.append(nums[i])
            self.dfs(nums, level+1, visited, out, res)
            out.pop()
            visited[i] = 0
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int> &num) {
        vector<vector<int>> res;
        vector<int> out;
        vector<int> visited(num.size(), 0);
        sort(num.begin(), num.end());
        permuteUniqueDFS(num, 0, visited, out, res);
        return res;
    }
    void permuteUniqueDFS(vector<int> &num, int level, vector<int> &visited, vector<int> &out, vector<vector<int>> &res) {
        if (level >= num.size()) res.push_back(out);
        else {
            for (int i = 0; i < num.size(); ++i) {
                if (visited[i] == 0) {
                    // skip duplicates
                    if (i > 0 && num[i] == num[i-1] && visited[i-1] == 0) continue;
                    visited[i] = 1;
                    out.push_back(num[i]);
                    permuteUniqueDFS(num, level + 1, visited, out, res);
                    out.pop_back();
                    visited[i] = 0;
                }
            }
        }
    }
};

class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        permuteUniqueDFS(nums, 0, nums.size()-1, res);
        return res;
    }
    // Do not use reference of nums and do not swap back after recursion
    void permuteUniqueDFS(vector<int> nums, int start, int end, vector<vector<int>> &res) {
        if (start > end) {
            res.push_back(nums);
            return;
        }
        for (int i = start; i <= end; ++i) {
            if (i != start && nums[start] == nums[i]) continue;
            swap(nums[start], nums[i]);
            permuteUniqueDFS(nums, start+1, end, res);
        }
    }
};
\end{lstlisting}


\section{Next Permutation (M)}
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory.\\

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\\
1,2,3 $->$ 1,3,2\\
3,2,1 $->$ 1,2,3\\
1,1,5 $->$ 1,5,1\\

\begin{lstlisting}
class Solution(object):
    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: None Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        for i in range(n - 2, -1, -1):
            # find the first decreasing element i from right to left
            if nums[i+1] > nums[i]:
                # find the next larger element than i
                for j in range(n - 1, i, -1):
                    if nums[j] > nums[i]: break
                # swap i and j
                nums[i], nums[j] = nums[j], nums[i]
                # reverse all elements after i
                nums[i+1:] = reversed(nums[i+1:])   
                return
        # if no next larger permutation, reverse the nums as the next permutation
        nums.reverse()            
\end{lstlisting}

\begin{lstlisting}
// 1. Find the first num that is smaller than 7:
//      1   2#  7   4   3   1
// 2. Find the first num that is larger than 2:
//      1   2   7   4   3#  1
// 3. Swap 2 and 3:
//      1   3#  7   4   2#  1
// 4. Reverse the left numbers after 3: 
//      1   3   1#  2#  4#  7#
class Solution {
public:
    void nextPermutation(vector<int> &num) {
        int i, j, n = num.size();
        for (i = n - 2; i >= 0; --i) {
            if (num[i + 1] > num[i]) { // step 1
                for (j = n - 1; j >= i; --j) {
                    if (num[j] > num[i]) break; // step 2
                }
                swap(num[i], num[j]); // step 3
                reverse(num.begin() + i + 1, num.end()); // step 4
                return;
            }
        }
        reverse(num.begin(), num.end()); // reverse nums if no next permutation
    }
};
\end{lstlisting}


\section{Permutation Sequence (M)}
The set [1,2,3,...,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, We get the following sequence (i.e., for n = 3):
    "123"\\
    "132"\\
    "213"\\
    "231"\\
    "312"\\
    "321"\\
Given n and k, return the kth permutation sequence.\\
Note: Given n will be between 1 and 9 inclusive.\\

\begin{lstlisting}
class Solution {
public:
    string getPermutation(int n, int k) {
        string res;
        string num = "123456789";
        vector<int> f(n, 1);
        for (int i = 1; i < n; ++i) {
            f[i] = f[i - 1] * i; // compute 1!, 2!, ...
        }
        --k; // align index
        for (int i = n; i >= 1; --i) {
            int j = k / f[i - 1];
            k %= f[i - 1];
            res.push_back(num[j]);
            num.erase(j, 1);
        }
        return res;
    }
};
\end{lstlisting}


\section{Combinations (M)}
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.\\

For example, If n = 4 and k = 2, a solution is: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4]]\\

\begin{lstlisting}
class Solution(object):
    def combine(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: List[List[int]]
        """
        out, res = [], []
        self.helper(n, k, 1, out, res)
        return res
    def helper(self, n, k, idx, out, res):
        if len(out) == k:
            res.append(list(out))
            return
        for i in range(idx, n+1):
            out.append(i)
            self.helper(n, k, i+1, out, res)
            out.pop()
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> res;
        vector<int> out;
        if (k > n) return res;
        combineDFS(res, out, 1, n, k);
        return res;
    }
    void combineDFS(vector<vector<int>> &res, vector<int> &out, int start, int end, int k) {
        if (k == 0) res.push_back(out);
        for (int i = start; i <= end; ++i) {
            out.push_back(i);
            combineDFS(res, out, i+1, end, k-1);
            out.pop_back();
        }
    }
};
\end{lstlisting}


\section{Combination Sum (M)}
Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times.\\

Note:\\
    All numbers (including target) will be positive integers.\\
    The solution set must not contain duplicate combinations.\\

For example, given candidate set [2, 3, 6, 7] and target 7, A solution set is: [ [7], [2, 2, 3] ]\\

\begin{lstlisting}
class Solution(object):
    def combinationSum(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        res = []
        out = []
        self.comb(candidates, target, 0, out, res)
        return res
    def comb(self, candidates, target, idx, out, res):
        if target < 0: return
        if target == 0:
            # It's needed to append a list to res for creating a list of lists
            res.append(list(out)) 
            return
        for i in range(idx, len(candidates), 1):
            out.append(candidates[i])
            self.comb(candidates, target-candidates[i], i, out, res)
            out.pop()
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> res;
        vector<int> out;
        sort(candidates.begin(), candidates.end());
        combinationSumDFS(candidates, target, out, res, 0);
        return res;
    }
    void combinationSumDFS(vector<int>& candidates, int target, vector<int>& out, vector<vector<int>> &res, int index) {
        if (target < 0) {
            return;
        } else if (target == 0) {
            res.push_back(out);
        } else {
            for (int i = index; i < candidates.size(); ++i) {
                out.push_back(candidates[i]);
                combinationSumDFS(candidates, target-candidates[i], out, res, i);
                out.pop_back();
            }
        }
    }
};
\end{lstlisting}


\section{Combination Sum II (M)}
Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination.\\

Note:\\
    All numbers (including target) will be positive integers.\\
    The solution set must not contain duplicate combinations.\\

For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] \\

\begin{lstlisting}
class Solution(object):
    def combinationSum2(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        out, res = [], []
        candidates.sort()
        self.comb(candidates, target, 0, out, res)
        return res
    def comb(self, candidates, target, idx, out, res):
        if target < 0: return
        if target == 0:
            res.append(list(out))
            return
        for i in range(idx, len(candidates)):
            # remove duplicates
            if i > idx and candidates[i] == candidates[i-1]: continue
            out.append(candidates[i])
            self.comb(candidates, target-candidates[i], i+1, out, res)
            out.pop()
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<vector<int>> res;
        vector<int> out;
        sort(candidates.begin(), candidates.end());
        combinationSum2DFS(candidates, target, out, res, 0);
        return res;        
    }
    void combinationSum2DFS(vector<int>& candidates, int target, vector<int>& out, vector<vector<int>> &res, int index) {
        if (target < 0) {
            return;
        } else if (target == 0) {
            res.push_back(out);
        } else {
            for (int i = index; i < candidates.size(); ++i) {
                if (i == index || candidates[i] != candidates[i-1]) { //skip duplicates
                    out.push_back(candidates[i]);
                    combinationSum2DFS(candidates, target-candidates[i], out, res, i+1);//update i to i+1
                    out.pop_back();
                }
            } 
        }
    }
};
\end{lstlisting}


\section{Combination Sum III (M)}
Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. \\

Example 1:\\
Input: k = 3, n = 7\\
Output: [[1,2,4]]\\

Example 2:\\
Input: k = 3, n = 9\\
Output:[[1,2,6], [1,3,5], [2,3,4]]\\

\begin{lstlisting}
class Solution(object):
    def combinationSum3(self, k, n):
        """
        :type k: int
        :type n: int
        :rtype: List[List[int]]
        """
        out, res = [], []
        self.comb(k, n, 1, out, res)
        return res
    def comb(self, k, n, idx, out, res):
        if k < 0 or n < 0: return
        if k == 0 and n == 0: 
            res.append(list(out))
            return
        for i in range(idx, 10):
            out.append(i)
            self.comb(k-1, n-i, i+1, out, res)
            out.pop()
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> res;
        vector<int> out;
        combinationSum3DFS(k, n, out, res, 1);
        return res;
    }
    void combinationSum3DFS(int k, int n, vector<int>& out, vector<vector<int>> &res, int index) {
        if (n < 0) {
            return;
        } else if (k == 0 && n == 0) {
            res.push_back(out);
        } else {
            for (int i = index; i <= 9; ++i) {
                out.push_back(i);
                combinationSum3DFS(k-1, n-i, out, res, i+1);
                out.pop_back();
            }
        }
    }
};
\end{lstlisting}

\section{Combination Sum IV (M)}
Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. \\

Example:\\
nums = [1, 2, 3]\\
target = 4\\

The possible combination ways are:\\
(1, 1, 1, 1)\\
(1, 1, 2)\\
(1, 2, 1)\\
(1, 3)\\
(2, 1, 1)\\
(2, 2)\\
(3, 1)\\

Note that different sequences are counted as different combinations. Therefore the output is 7.\\

\begin{lstlisting}
# Get all combinations and count
class Solution(object):
    def combinationSum4(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        out, res = [], []
        self.comb(nums, target, 0, out, res)
        return len(res)
    def comb(self, nums, target, idx, out, res):
        if target < 0: return
        if target == 0:
            res.append(list(out))
            return
        for i in range(len(nums)):
            out.append(nums[i])
            self.comb(nums, target-nums[i], i, out, res)
            out.pop()

# Count combinations
class Solution(object):
    def combinationSum4(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        if target == 0:
            return 1
        res = 0
        for i in range(len(nums)):
            if target >= nums[i]:
                res += self.combinationSum4(nums, target-nums[i])
        return res
    
# DP
class Solution(object):
    def combinationSum4(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        dp = [0 for i in range(target+1)]
        dp[0] = 1
        for i in range(1, target+1):
            for j in nums:
                if i >= j: dp[i] += dp[i-j]
        return dp[-1]
\end{lstlisting}

\section{Target Sum (M)}
 You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.\\

Find out how many ways to assign symbols to make sum of integers equal to target S.\\

Example 1:\\

Input: nums is [1, 1, 1, 1, 1], S is 3. \\
Output: 5\\
Explanation: \\

-1+1+1+1+1 = 3\\
+1-1+1+1+1 = 3\\
+1+1-1+1+1 = 3\\
+1+1+1-1+1 = 3\\
+1+1+1+1-1 = 3\\

There are 5 ways to assign symbols to make the sum of nums be target 3.\\

Note:\\

    The length of the given array is positive and will not exceed 20.\\
    The sum of elements in the given array will not exceed 1000.\\
    Your output answer is guaranteed to be fitted in a 32-bit integer.\\

\begin{lstlisting}
# Time: O(2^N)  Space: O(N)
class Solution(object):
    def findTargetSumWays(self, nums, S):
        """
        :type nums: List[int]
        :type S: int
        :rtype: int
        """
        idx = 0
        self.res = 0
        self.helper(nums, S, idx)
        return self.res
    def helper(self, nums, S, idx):
        if idx == len(nums):
            if S == 0: self.res += 1
            return
        self.helper(nums, S - nums[idx], idx + 1)
        self.helper(nums, S + nums[idx], idx + 1)
\end{lstlisting}
     
\section{Factor Combinations (M)}
Numbers can be regarded as product of its factors. For example, 8 = 2 x 2 x 2 = 2 x 4.\\

Write a function that takes an integer n and return all possible combinations of its factors.\\

Note: \\
    Each combination's factors must be sorted ascending, for example: The factors of 2 and 6 is [2, 6], not [6, 2].\\
    You may assume that n is always positive.\\
    Factors should be greater than 1 and less than n.\\

Examples: \\
input: 1
output: 
[]\\

input: 37
output: 
[]\\

input: 12
output:
[
  [2, 6],
  [2, 2, 3],
  [3, 4]
]\\

input: 32
output:
[
  [2, 16],
  [2, 2, 8],
  [2, 2, 2, 4],
  [2, 2, 2, 2, 2],
  [2, 4, 4],
  [4, 8]
]\\

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> getFactors(int n) {
        vector<vector<int>> res;
        dfs(n, 2, {}, res);
        return res;
    }
    void dfs(int n, int start, vector<int> out, vector<vector<int>> &res) {
        if (n == 1) {
            if (out.size() > 1) res.push_back(out);
        } else {
            for (int i = start; i <= n; ++i) {
                if (n % i == 0) {
                    out.push_back(i);
                    dfs(n / i, i, out, res);
                    out.pop_back();
                }
            }
        }
    }
};
\end{lstlisting}


\section{Letter Combinations of a Phone Number (M)}
Given a digit string, return all possible letter combinations that the number could represent.\\

Input:Digit string "23"\\
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].\\

Note:Although the above answer is in lexicographical order, your answer could be in any order you want. \\

\begin{lstlisting}
class Solution(object):            
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """
        if not digits: return []
        idx = 0
        out = ''
        res = []
        d = {0:'', 1:'', 2:'abc', 3:'def', 4:'ghi', 5:'jkl',
             6:'mno', 7:'pqrs', 8:'tuv', 9:'wxyz'}
        self.dfs(digits, d, idx, out, res)
        return res
    def dfs(self, digits, d, idx, out, res):
        if idx == len(digits):
            res.append(out)
            return
        digit = int(digits[idx])
        letters = d[digit]
        for letter in letters:
            self.dfs(digits, d, idx + 1, out + letter, res)
\end{lstlisting}

\begin{lstlisting}
// 1. Recursion
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        vector<string> res;
        if (digits.empty()) return res;
        string dict[] = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        letterCombinationsDFS(digits, dict, 0, "", res);
        return res;
    }
    void letterCombinationsDFS(string digits, string dict[], int level, string out, vector<string> &res) {
        if (level == digits.size()) res.push_back(out);
        else {
            string str = dict[digits[level] - '2'];
            for (int i = 0; i < str.size(); ++i) {
                out.push_back(str[i]);
                letterCombinationsDFS(digits, dict, level + 1, out, res);
                out.pop_back();
            }
        }
    }
};

// 2. Iterative
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        vector<string> res;
        if (digits.empty()) return res;
        string dict[] = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        res.push_back("");
        for (int i = 0; i < digits.size(); ++i) {
            int n = res.size();
            string str = dict[digits[i] - '2'];
            for (int j = 0; j < n; ++j) {
                string tmp = res.front();
                res.erase(res.begin());
                for (int k = 0; k < str.size(); ++k) {
                    res.push_back(tmp + str[k]);
                }
            }
        }
        return res;
    }
};

// 3. Iterative 2
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        vector<string> res;
        if (digits.empty()) return res;
        vector<string> str = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        res.push_back("");
        for (int i = 0; i < digits.size(); ++i) {
            vector<string> tmp;
            int index = digits[i] - '0';
            for (int j = 0; j < str[index].size(); ++j) {
                for (int k = 0; k < res.size(); ++k) {
                    tmp.push_back(res[k]+str[index][j]);
                }
            }
            res = tmp;
        }
        return res;
    }
};
\end{lstlisting}


\section{Walls and Gates (M)}
You are given a m x n 2D grid initialized with these three possible values.\\
    -1 - A wall or an obstacle.\\
    0 - A gate.\\
    INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.\\

Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.\\

For example, given the 2D grid:\\
INF  -1  0  INF\\
INF INF INF  -1\\
INF  -1 INF  -1\\
  0  -1 INF INF\\

After running your function, the 2D grid should be:\\
  3  -1   0   1\\
  2   2   1  -1\\
  1  -1   2  -1\\
  0  -1   3   4\\

\begin{lstlisting}
def wallsAndGates(self, rooms):
	dist = 0
	for i in range(len(rooms)):
		for j in range(len(rooms[0])):
			# start the dfs search from the gate
			if rooms[i][j] == 0: self.dfs(rooms, i, j, dist)
def self.dfs(self, rooms, i, j, dist):
	if i < 0 or i >= len(rooms) or \
	   j < 0 or j >= len(rooms[0]) or \
	   rooms[i][j] < dist:
	   return
	# update the current room val based on 
	# the distance between the current room and the gate
	rooms[i][j] = dist 
	# search 4 directions from the current room and increase the distance
	self.dfs(rooms, i + 1, j, dist + 1)
	self.dfs(rooms, i - 1, j, dist + 1)
	self.dfs(rooms, i, j + 1, dist + 1)
	self.dfs(rooms, i, j - 1, dist + 1)
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    void wallsAndGates(vector<vector<int>>& rooms) {
        for (int i = 0; i < rooms.size(); ++i) {
            for (int j = 0; j < rooms[i].size(); ++j) {
                if (rooms[i][j] == 0) {
                    dfs(rooms, i, j, 0);
                }
            }
        }
    }
    void dfs(vector<vector<int>> &rooms, int i, int j, int val) {
        if (i < 0 || i >= rooms.size() || j < 0 || j >= rooms[i].size() || rooms[i][j] < val) return;
        rooms[i][j] = val;
        dfs(rooms, i + 1, j, val + 1);
        dfs(rooms, i - 1, j, val + 1);
        dfs(rooms, i, j + 1, val + 1);
        dfs(rooms, i, j - 1, val + 1);
    }
};
\end{lstlisting}

\section{Shortest Path in Binary Matrix (M)}
In an N by N square grid, each cell is either empty (0) or blocked (1). Return the length of the shortest such clear path from top-left to bottom-right.  If such a path does not exist, return -1.\\

\begin{lstlisting}
class Solution(object):
    def shortestPathBinaryMatrix(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        n = len(grid)
        if grid[0][0] == 1 or grid[n-1][n-1] == 1:
            return -1
        q = [(0, 0, 1)]
        # search cooridantes (i, j) and the depth d with BFS
        for i, j, d in q:
            # reach the bottom-right, d is the shortest path
            if i == n-1 and j == n-1: return d
            # search 8 directions
            for x, y in ((i-1,j-1),(i-1,j),(i-1,j+1),\
                         (i,j-1),(i,j+1),\
                         (i+1,j-1),(i+1,j),(i+1,j+1)):
                if 0 <= x < n and 0 <= y < n and grid[x][y] == 0:
                    grid[x][y] = 1 # for visited grid, set its value to 1
                    q.append((x, y, d+1)) # add the path to q
        return -1
            
# Standard BFS
class Solution(object):
    def shortestPathBinaryMatrix(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        n = len(grid)
        if grid[0][0] == 1 or grid[n-1][n-1] == 1:
            return -1
        q = [(0, 0, 1)]
        visited = [[False for j in range(n)] for i in range(n)]
        while q:
            i, j, d = q.pop()
            if i == n-1 and j == n-1: return d
            for x, y in ((i-1,j-1),(i-1,j),(i-1,j+1),\
                         (i,j-1),(i,j+1),\
                         (i+1,j-1),(i+1,j),(i+1,j+1)):
                if 0 <= x < n and 0 <= y < n and \
                   grid[x][y] == 0 and visited[x][y] == False:
                    visited[x][y] = True 
                    q.insert(0, (x, y, d+1)) 
        return -1
\end{lstlisting}

\section{Surrounded Regions (M)}
Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region.\\

For example,\\
X X X X\\
X O O X\\
X X O X\\
X O X X\\

After running your function, the board should be:\\
X X X X\\
X X X X\\
X X X X\\
X O X X\\

\begin{lstlisting}
class Solution {
public:
    void solve(vector<vector<char> >& board) {
        // if O exists on the most outside rows and columns of the board,
        // the O will never be surrounded by X
        for (int i = 0; i < board.size(); ++i) {
            for (int j = 0; j < board[i].size(); ++j) {
                if ((i == 0 || i == board.size() - 1 || j == 0 || j == board[i].size() - 1) 
                    && board[i][j] == 'O')
                    solveDFS(board, i, j);
            }
        }
        // flip all O to X, flip all N to O
        for (int i = 0; i < board.size(); ++i) {
            for (int j = 0; j < board[i].size(); ++j) {
                if (board[i][j] == 'O') board[i][j] = 'X';
                if (board[i][j] == 'N') board[i][j] = 'O';
            }
        }
    }
    // search if there are any O's connected to the current O
    // set all of them to N
    void solveDFS(vector<vector<char> > &board, int i, int j) {
        if (board[i][j] == 'O') {
            board[i][j] = 'N';
            if (i > 0 && board[i - 1][j] == 'O') 
                solveDFS(board, i - 1, j);
            if (i < board.size() - 1 && board[i + 1][j] == 'O') 
                solveDFS(board, i + 1, j);
            if (j > 1 && board[i][j - 1] == 'O') 
                solveDFS(board, i, j - 1);
            if (j < board[i].size() - 1 && board[i][j + 1] == 'O') 
                solveDFS(board, i, j + 1);
        }
    }
};
\end{lstlisting}

\section{Battleships in a Board (M)}
Given an 2D board, count how many battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:\\

    You receive a valid board, made of only battleships or empty slots.\\
    Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.\\
    At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.\\
    
\begin{lstlisting}
# Find the first X of the battleship
# skip all . and intermediate X
class Solution(object):
    def countBattleships(self, board):
        """
        :type board: List[List[str]]
        :rtype: int
        """
        res = 0
        m = len(board)
        n = len(board[0])
        for i in range(m):
            for j in range(n):
                if (board[i][j] == '.') or \
                   (i > 0 and board[i-1][j] == 'X') or \
                   (j > 0 and board[i][j-1] == 'X'):
                    continue
                res += 1
        return res
\end{lstlisting}


\section{Number of Islands (M)}
Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\\

Example 1:\\
11110\\
11010\\
11000\\
00000\\
Answer: 1\\

Example 2:\\
11000\\
11000\\
00100\\
00011\\
Answer: 3\\

\begin{lstlisting}
class Solution(object):
    def numIslands(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: int
        """
        if not grid or not grid[0]: return 0
        m, n = len(grid), len(grid[0])
        visited = [[False for j in range(n)] for i in range(m)]
        res = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '0' or visited[i][j]: continue
                self.dfs(grid, visited, i, j)
                res += 1
        return res
    def dfs(self, grid, visited, i, j):
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or \
           grid[i][j] == '0' or visited[i][j]: return
        visited[i][j] = True
        self.dfs(grid, visited, i - 1, j)
        self.dfs(grid, visited, i + 1, j)
        self.dfs(grid, visited, i, j - 1)
        self.dfs(grid, visited, i, j + 1)
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    int numIslands(vector<vector<char> > &grid) {
        if (grid.empty() || grid[0].empty()) return 0;
        int m = grid.size(), n = grid[0].size(), res = 0;
        vector<vector<bool> > visited(m, vector<bool>(n, false));
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == '1' && !visited[i][j]) {
                    numIslandsDFS(grid, visited, i, j);
                    ++res;
                }
            }
        }
        return res;
    }
    void numIslandsDFS(vector<vector<char> > &grid, vector<vector<bool> > &visited, int x, int y) {
        if (x < 0 || x >= grid.size()) return;
        if (y < 0 || y >= grid[0].size()) return;
        if (grid[x][y] != '1' || visited[x][y]) return;
        visited[x][y] = true; // grid[x][y] is visited now
        // search other 4 direction of grid[x][y]
        numIslandsDFS(grid, visited, x - 1, y);
        numIslandsDFS(grid, visited, x + 1, y);
        numIslandsDFS(grid, visited, x, y - 1);
        numIslandsDFS(grid, visited, x, y + 1);
    }
};
\end{lstlisting}


\section{Number of Islands II (H)}
A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. \\

Example:\\
Given m = 3, n = 3, positions = [[0,0], [0,1], [1,2], [2,1]].\\

Initially, the 2d grid grid is filled with water. (Assume 0 represents water and 1 represents land).\\
0 0 0\\
0 0 0\\
0 0 0\\

Operation \#1: addLand(0, 0) turns the water at grid[0][0] into a land.\\
1 0 0\\
0 0 0   Number of islands = 1\\
0 0 0\\

Operation \#2: addLand(0, 1) turns the water at grid[0][1] into a land.\\
1 1 0\\
0 0 0   Number of islands = 1\\
0 0 0\\

Operation \#3: addLand(1, 2) turns the water at grid[1][2] into a land.\\
1 1 0\\
0 0 1   Number of islands = 2\\
0 0 0\\

Operation \#4: addLand(2, 1) turns the water at grid[2][1] into a land.\\
1 1 0\\
0 0 1   Number of islands = 3\\
0 1 0\\

We return the result as an array: [1, 1, 2, 3]\\

Challenge: Can you do it in time complexity O(k log mn), where k is the length of the positions?\\

\begin{lstlisting}
class Solution {
public:
    vector<int> numIslands2(int m, int n, vector<pair<int, int>>& positions) {
        vector<int> res;
        if (m <= 0 || n <= 0) return res;
        vector<int> roots(m * n, -1);
        int cnt = 0;
        vector<vector<int> > dirs{{0, -1}, {-1, 0}, {0, 1}, {1, 0}};
        for (auto a : positions) {
            int id = n * a.first + a.second;
            roots[id] = id;
            ++cnt;
            for (auto d : dirs) {
                int x = a.first + d[0], y = a.second + d[1];
                int cur_id = n * x + y;
                if (x < 0 || x >= m || y < 0 || y >= n || roots[cur_id] == -1) continue;
                int new_id = findRoots(roots, cur_id);
                if (id != new_id) {
                    roots[id] = new_id;
                    id = new_id;
                    --cnt;
                }
            }
            res.push_back(cnt);
        }
        return res;
    }
    int findRoots(vector<int> &roots, int id) {
        while (id != roots[id]) {
            roots[id] = roots[roots[id]];
            id = roots[id];
        }
        return id;
    }
};
\end{lstlisting}


\section{Word Search (M)}
Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

For example,
Given board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]\\

word = "ABCCED", returns true,\\
word = "SEE", returns true,\\
word = "ABCB", returns false.\\

\begin{lstlisting}
class Solution(object):
    def exist(self, board, word):
        """
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """
        m, n = len(board), len(board[0])
        visited = [[False for j in range(n)] for i in range(m)]
        idx, res = 0, 0
        for i in range(m):
            for j in range(n):
                if self.search(board, word, idx, i, j, visited): return True
        return False
    def search(self, board, word, idx, i, j, visited):
        if idx == len(word): return True
        if i < 0 or i >= len(visited) or j < 0 or j >= len(visited[0]) or \
           visited[i][j] or board[i][j] != word[idx]:
            return False
        visited[i][j] = True
        # if we can find the next char in any direction, then res is true
        res = self.search(board, word, idx+1, i+1, j, visited) or \
              self.search(board, word, idx+1, i, j+1, visited) or \
              self.search(board, word, idx+1, i-1, j, visited) or \
              self.search(board, word, idx+1, i, j-1, visited)
        # reset visited status
        visited[i][j] = False
        return res
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    bool exist(vector<vector<char> > &board, string word) {
        if (word.empty()) return true;
        if (board.empty() || board[0].empty()) return false;
        vector<vector<bool> > visited(board.size(), vector<bool>(board[0].size(), false));
        for (int i = 0; i < board.size(); ++i) {
            for (int j = 0; j < board[i].size(); ++j) {
                if (search(board, word, 0, i, j, visited)) return true;
            }
        }
        return false;
    }
    bool search(vector<vector<char> > &board, string word, int idx, int i, int j, vector<vector<bool> > &visited) {
        if (idx == word.size()) return true;
        if (i < 0 || j < 0 || i >= board.size() || j >= board[0].size() || visited[i][j] || board[i][j] != word[idx]) return false;
        visited[i][j] = true;
        bool res = search(board, word, idx + 1, i - 1, j, visited) 
                 || search(board, word, idx + 1, i + 1, j, visited)
                 || search(board, word, idx + 1, i, j - 1, visited)
                 || search(board, word, idx + 1, i, j + 1, visited);
        visited[i][j] = false;
        return res;
    }
};
\end{lstlisting}

\section{Word Search debugging (Microsoft phone interview 2019.5.31)}
\begin{lstlisting}
def dfs(matrix, target, row, col, path, results, visited):
    # bug 4
    if target == '':
        results.append(path)
        return
    m = len(matrix)
    n = len(matrix[0])
    # bug 1: skip corner conditions
    if row < 0 or col < 0 or row >= m or col >= n: return
    if target[0] != matrix[row][col]:
        return
    # bug 1: skip visited element
    if visited[row][col]:
        return
    # bug 3: update visited array
    visited[row][col] = True
    dfs(matrix, target[1:], row-1, col, path + [(row, col)], results, visited)
    dfs(matrix, target[1:], row+1, col, path + [(row, col)], results, visited)
    dfs(matrix, target[1:], row, col-1, path + [(row, col)], results, visited)
    dfs(matrix, target[1:], row, col+1, path + [(row, col)], results, visited)
    visited[row][col] = False

def findWords(matrix, target):
    m = len(matrix)
    n = len(matrix[0])
    results = []
    # bug 2: need to add a visited 2d array
    visited = [ [ False for col in range(n) ] for row in range(m) ]
    for row in range(m):
        for col in range(n):
            dfs(matrix, target, row, col, [], results, visited)
    return results

if __name__ == '__main__':
    matrix = [ 'OMIC',
               'OSOR',
               'FTAZ',
               'BYWK' ]
    target = 'MICROSOFT'
    print(findWords(matrix, target))
\end{lstlisting}

\section{Word Search II (H)}
Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

For example,
Given words = ["oath","pea","eat","rain"] and board =
[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]\\

Return ["eat","oath"].\\

Note:
You may assume that all inputs are consist of lowercase letters a-z.\\

You would need to optimize your backtracking to pass the larger test. Could you stop backtracking earlier?\\

If the current candidate does not exist in all words' prefix, you could stop backtracking immediately. What kind of data structure could answer such query efficiently? Does a hash table work? Why or why not? How about a Trie? If you would like to learn how to implement a basic trie, please work on this problem: Implement Trie (Prefix Tree) first.\\

\begin{lstlisting}
class Solution {
public:
    struct TrieNode {
        TrieNode *child[26];
        string str;
        TrieNode() : str("") {
            for (auto &a : child) a = NULL;
        }
    };
    struct Trie {
        TrieNode *root;
        Trie() : root(new TrieNode()) {}
        void insert(string s) {
            TrieNode *p = root;
            for (auto &a : s) {
                int i = a - 'a';
                if (!p->child[i]) p->child[i] = new TrieNode();
                p = p->child[i];
            }
            p->str = s;
        }
    };
    vector<string> findWords(vector<vector<char> >& board, vector<string>& words) {
        vector<string> res;
        if (words.empty() || board.empty() || board[0].empty()) return res;
        vector<vector<bool> > visit(board.size(), vector<bool>(board[0].size(), false));
        Trie T;
        for (auto &a : words) T.insert(a);
        for (int i = 0; i < board.size(); ++i) {
            for (int j = 0; j < board[i].size(); ++j) {
                if (T.root->child[board[i][j] - 'a']) {
                    search(board, T.root->child[board[i][j] - 'a'], i, j, visit, res);
                }
            }
        }
        return res;
    }
    void search(vector<vector<char> > &board, TrieNode *p, int i, int j, vector<vector<bool> > &visit, vector<string> &res) { 
        if (!p->str.empty()) {
            res.push_back(p->str);
            p->str.clear();
        }
        int d[][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        visit[i][j] = true;
        for (auto &a : d) {
            int nx = a[0] + i, ny = a[1] + j;
            if (nx >= 0 && nx < board.size() && ny >= 0 && ny < board[0].size() && !visit[nx][ny] && p->child[board[nx][ny] - 'a']) {
                search(board, p->child[board[nx][ny] - 'a'], nx, ny, visit, res);
            }
        }
        visit[i][j] = false;
    }
};
\end{lstlisting}

\section{Accounts Merge (M)}
Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.\\

Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.\\

After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.\\

Example 1:\\

Input: \\
$accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]]
Output: [["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]]$\\
Explanation: \\
The first and third John's are the same person as they have the common email "johnsmith@mail.com".
The second John and Mary are different people as none of their email addresses are used by other accounts.\\
We could return these lists in any order, for example the answer $[['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], 
['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']]$ would still be accepted.\\

Note:\\
The length of accounts will be in the range [1, 1000].\\
The length of accounts[i] will be in the range [1, 10].\\
The length of accounts[i][j] will be in the range [1, 30].\\

\begin{lstlisting}
# 1. Give each account an ID, based on the index of it within the list of accounts.
# 2. Build an emails_accounts_map that maps an email to a list of accounts, which can be used to track which email is linked to which account. This is essentially our graph.
# 3. Perform a DFS on each account in accounts list and look up emails_accounts_map to tell which accounts are linked to that particular account via common emails. This will make sure we visit each account only once. This is a recursive process and we should collect all the emails that we encounter along the way.
# 4 Sort the collected emails and add it to final results, res along with the name.
class Solution(object):
    def accountsMerge(self, accounts):
        """
        :type accounts: List[List[str]]
        :rtype: List[List[str]]
        """
        visited = [False] * len(accounts)
        emails_accounts_map = {}
        res = []
        # Build the mapping between email and account idx in accounts
        for idx, account in enumerate(accounts):
            for j in range(1, len(account)):
                email = account[j]
                if email in emails_accounts_map:
                    emails_accounts_map[email].append(idx)
                else:
                    emails_accounts_map[email] = [idx]
        # Perform DFS for accounts and add to results.
        for idx, account in enumerate(accounts):
            if visited[idx]: continue
            name, emails = account[0], set()
            self.dfs(idx, emails, visited, accounts, emails_accounts_map)
            res.append([name] + sorted(emails))
        return res
    
    def dfs(self, i, emails, visited, accounts, emails_accounts_map):
        if visited[i]: return
        visited[i] = True
        for j in range(1, len(accounts[i])):
            email = accounts[i][j]
            emails.add(email)
            for idx in emails_accounts_map[email]:
                self.dfs(idx, emails, visited, accounts, emails_accounts_map)
\end{lstlisting}

\section{Word Ladder (M)}
Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:\\
    Only one letter can be changed at a time\\
    Each intermediate word must exist in the word list\\

For example,\\
Given:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]
As one shortest transformation is $"hit" -> "hot" -> "dot" -> "dog" -> "cog"$,
return its length 5.\\

Note:\\
    Return 0 if there is no such transformation sequence.\\
    All words have the same length.\\
    All words contain only lowercase alphabetic characters.\

\begin{lstlisting}
class Solution(object):
    def ladderLength(self, beginWord, endWord, wordList):
        """
        :type beginWord: str
        :type endWord: str
        :type wordList: List[str]
        :rtype: int
        """
        wordList = set(wordList) #avoid TLE
        q = [(beginWord, 1)]
        visited = set()
        alpha = string.ascii_lowercase  #'abcd...z'
        while q:
            word, length = q.pop()
            if word == endWord:
                return length
            # for each char in word, iterate it from a to z
            for i in range(len(word)):
                for ch in alpha:
                    new_word = word[:i] + ch + word[i+1:]
                    # if any combination exists in wordList and it's not visited
                    if new_word in wordList and new_word not in visited:
                        # save that combination to queue and increase the length
                        q.insert(0, (new_word, length + 1))
                        # update visited
                        visited.add(new_word)
        return 0
\end{lstlisting}


\begin{lstlisting}
class Solution {
public:
    int ladderLength(string beginWord, string endWord, unordered_set<string>& wordDict) {
        unordered_map<string, int> m;
        queue<string> q;
        m[beginWord] = 1;
        q.push(beginWord);
        while (!q.empty()) {
            string word = q.front(); q.pop();
            for (int i = 0; i < word.size(); ++i) {
                string newWord = word;
                for (char ch = 'a'; ch <= 'z'; ++ch) {
                    newWord[i] = ch;
                    if (newWord == endWord) return m[word] + 1;
                    if (wordDict.find(newWord) != wordDict.end() && m.find(newWord) == m.end()) {
                        q.push(newWord);
                        m[newWord] = m[word] + 1;
                    }   
                }
            }
        }
        return 0;
    }
};
\end{lstlisting}


\section{Word Ladder II (H)}
Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:\\
    Only one letter can be changed at a time\\
    Each intermediate word must exist in the word list\\

For example,\\
Given:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]\\

Return
  [
    ["hit","hot","dot","dog","cog"],
    ["hit","hot","lot","log","cog"]
  ]\\

Note:\\
    All words have the same length.\\
    All words contain only lowercase alphabetic characters.\\

\begin{lstlisting}
class Solution {
public:
    vector<vector<string> > findLadders(string start, string end, unordered_set<string> &dict) {
        vector<vector<string> > res;
        dict.insert(end);
        vector<string> p;
        p.push_back(start);
        queue<vector<string> > paths;
        paths.push(p);
        int level = 1, minLevel = INT_MAX;
        unordered_set<string> words;
        while (!paths.empty()) {
            vector<string> path = paths.front();
            paths.pop();
            if (path.size() > level) {
                for (string w : words) dict.erase(w);
                words.clear();
                level = path.size();
                if (level > minLevel) break;
            }
            string last = path.back();
            for (int i = 0; i < last.size(); ++i) {
                string newLast = last;
                for (char ch = 'a'; ch <= 'z'; ++ch) {
                    newLast[i] = ch;
                    if (dict.find(newLast) != dict.end()) {
                        words.insert(newLast);
                        vector<string> nextPath = path;
                        nextPath.push_back(newLast);
                        if (newLast == end) {
                            res.push_back(nextPath);
                            minLevel = level;
                        } else paths.push(nextPath);
                    }
                }
            }            
        }
        return res;
    }
};
\end{lstlisting}


\section{Course Schedule (M)}
There are a total of n courses you have to take, labeled from 0 to n-1.

Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?

Example 1:

Input: 2, [[1,0]] 
Output: true
Explanation: There are a total of 2 courses to take. 
             To take course 1 you should have finished course 0. So it is possible.

Example 2:

Input: 2, [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
             To take course 1 you should have finished course 0, and to take course 0 you should
             also have finished course 1. So it is impossible.

Note:

    The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.
    You may assume that there are no duplicate edges in the input prerequisites.


\begin{lstlisting}
# Detecting if there is a cycle in the directed graph represented by prerequisites
# We need to transform it to the adjacency-list representation. If course u is a prerequisite of course v, then the adjacency list of u will contain v.

# BFS: the number of visited nodes should be equal to the number of courses,
# otherwise a cycle exists
class Solution(object):
    def canFinish(self, numCourses, prerequisites):
        """
        :type numCourses: int
        :type prerequisites: List[List[int]]
        :rtype: bool
        """
        # create graph and indegree list
        # graph is a dict that mapping a node and a list of its prerequisites
        graph = {i: [] for i in range(numCourses)}
        indegree = [0 for i in range(numCourses) ]
        # x -> y in graph
        # so x is the prerequisite of y, and the indegree of y is added by 1
        for x, y in prerequisites:
            graph[y].append(x)
            indegree[x] += 1
        
        # create queue that saves all courses without prerequisites
        # i.e. indegree = 0
        queue = []
        for i in range(numCourses):
            if indegree[i] == 0:
                queue.insert(0, i)
        
        # perform BFS
        visited = 0        
        while queue:
            node = queue.pop()
            visited += 1
            for v in graph[node]:
                # for each visited node, reduce the indegree of all its neighbors by 1
                indegree[v] -= 1
                # if any node with 0 indegree, add it to queue
                if indegree[v] == 0: queue.insert(0, v)
                    
        # all nodes should be visited if no cycle, otherwise a cycle exists
        return visited == numCourses
    
    
# # DFS: in each visit, we start from a node and keep visiting its neighbors, 
# # if at a time we return to a visited node, there is a cycle. 
# # Otherwise, start again from another unvisited node and repeat this process.
# class Solution(object):
#     def canFinish(self, numCourses, prerequisites):
#         """
#         :type numCourses: int
#         :type prerequisites: List[List[int]]
#         :rtype: bool
#         """
\end{lstlisting}

\section{Course Schedule II (M)}
There are a total of n courses you have to take, labeled from 0 to n-1.

Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.

There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.

Example 1:

Input: 2, [[1,0]] 
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished   
             course 0. So the correct course order is [0,1] .

Example 2:

Input: 4, [[1,0],[2,0],[3,1],[3,2]]
Output: [0,1,2,3] or [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both     
             courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. 
             So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .

Note:

    The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.
    You may assume that there are no duplicate edges in the input prerequisites.
\begin{lstlisting}
# Detecting if there is a cycle in the directed graph represented by prerequisites
# We need to transform it to the adjacency-list representation. If course u is a prerequisite of course v, then the adjacency list of u will contain v.

# BFS: the number of visited nodes should be equal to the number of courses,
# otherwise a cycle exists
class Solution(object):
    def findOrder(self, numCourses, prerequisites):
        """
        :type numCourses: int
        :type prerequisites: List[List[int]]
        :rtype: List[int]
        """
        # create graph and indegree list
        # graph is a dict that mapping a node and a set of its prerequisites
        graph = {i: [] for i in range(numCourses)}
        indegree = [0 for i in range(numCourses) ]
        # x -> y in graph
        # so x is the prerequisite of y, and the indegree of y is added by 1
        for x, y in prerequisites:
            graph[y].append(x)
            indegree[x] += 1
        
        # create queue that saves all courses without prerequisites
        # i.e. indegree = 0
        queue = []
        for i in range(numCourses):
            if indegree[i] == 0:
                queue.insert(0, i)
        
        # perform BFS
        visited = 0 
        res = []
        while queue:
            node = queue.pop()
            res.append(node)
            visited += 1
            for v in graph[node]:
                # for each visited node, reduce the indegree of all its neighbors by 1
                indegree[v] -= 1
                # if any node with 0 indegree, add it to queue
                if indegree[v] == 0: queue.insert(0, v)
                    
        # all nodes should be visited if no cycle, otherwise a cycle exists
        if visited == numCourses:
            return res
        else:
            return []
\end{lstlisting}

\section{Course Schedule III (H)}
There are n different online courses numbered from 1 to n. Each course has some duration(course length) t and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day.

Given n online courses represented by pairs (t,d), your task is to find the maximal number of courses that can be taken.

Example:

Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
Output: 3
Explanation: 
There're totally 4 courses, but you can take 3 courses at most:
First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.
Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. 
Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. 
The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.

 

Note:

    The integer 1 <= d, t, n <= 10,000.
    You can't take two courses simultaneously.

\begin{lstlisting}
\end{lstlisting}

\section{Alien Dictionary (H)}
There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.

Example 1:

Input:
[
  "wrt",
  "wrf",
  "er",
  "ett",
  "rftt"
]

Output: "wertf"

Example 2:

Input:
[
  "z",
  "x"
]

Output: "zx"

Example 3:

Input:
[
  "z",
  "x",
  "z"
] 

Output: "" 

Explanation: The order is invalid, so return "".

Note:

    You may assume all letters are in lowercase.
    You may assume that if a is a prefix of b, then a must appear before b in the given dictionary.
    If the order is invalid, return an empty string.
    There may be multiple valid order of letters, return any one of them is fine.
\begin{lstlisting}
class Solution {
public:
    string alienOrder(vector<string>& words) {
        set<pair<char, char>> st;
        unordered_set<char> ch;
        vector<int> in(256, 0);
        queue<char> q;
        string res = "";
        for (auto a : words) ch.insert(a.begin(), a.end());
        for (int i = 0; i < (int)words.size() - 1; ++i) {
            int mn = min(words[i].size(), words[i + 1].size()), j = 0;
            for (; j < min(words[i].size(), words[i + 1].size()); ++j) {
                if (words[i][j] != words[i + 1][j]) {
                    st.insert(make_pair(words[i][j], words[i + 1][j]));
                    break;
                }
            }
            if (j == mn && words[i].size() > words[i + 1].size()) return "";
        }
        for (auto a : st) ++in[a.second];
        for (auto a : ch) {
            if (in[a] == 0) {
                q.push(a);
                res += a;
            } 
        }
        while (!q.empty()) {
            char c = q.front(); q.pop();
            for (auto a : st) {
                if (a.first == c) {
                    --in[a.second];
                    if (in[a.second] == 0) {
                        q.push(a.second);
                        res += a.second;
                    }
                }
            }
        }
        return res.size() == ch.size() ? res : "";
    }
};
\end{lstlisting}






