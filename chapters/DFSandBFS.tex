\chapter{DFS and BFS}
\section{Subset (M)}
Given a set of distinct integers, nums, return all possible subsets.\\
Note: The solution set must not contain duplicate subsets.\\
For example,
If nums = [1,2,3], a solution is:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]\\

\begin{lstlisting}
// 1. Recursive
class Solution {
public:
    vector<vector<int>> subsets(vector<int> &nums) {
        vector<vector<int>> res;
        vector<int> out;
        sort(nums.begin(), nums.end());
        getSubsets(nums, res, out, 0);
        return res;
    }
    void getSubsets(vector<int> &nums, vector<vector<int>> &res, vector<int> &out, int pos) {
        res.push_back(out);
        for (int i = pos; i < nums.size(); ++i) {
            out.push_back(nums[i]);
            getSubsets(nums, res, out, i+1);
            out.pop_back();
        }
    }
};

// 2. Iterative
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res(1, vector<int>());
        for (int i = 0; i < nums.size(); ++i) {
            int n = res.size();
            for (int j = 0; j < n; ++j) {
                res.push_back(res[j]);
                res.back().push_back(nums[i]);
            }
        }
        return res;
    }
};
\end{lstlisting}


\section{Subset II (M)}
Given a collection of integers that might contain duplicates, nums, return all possible subsets.\\
Note: The solution set must not contain duplicate subsets.\\
For example,
If nums = [1,2,2], a solution is:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]\\

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        vector<int> out;
        getSubsets(nums, res, out, 0);
        return res;
    }
    void getSubsets(vector<int>& nums, vector<vector<int>>& res, vector<int>& out, int pos) {
        res.push_back(out);
        for (int i = pos; i < nums.size(); ++i) {
            if (i == pos || nums[i] != nums[i-1]) {
                out.push_back(nums[i]);
                getSubsets(nums, res, out, i+1);
                out.pop_back();
            }
        }
    }
};
\end{lstlisting}


\section{Permutations (M)}
Given a collection of distinct numbers, return all possible permutations. \\

For example,
[1,2,3] have the following permutations: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]\\

\begin{lstlisting}
// 1. Use visited vector
class Solution {
public:
    vector<vector<int> > permute(vector<int> &num) {
        vector<vector<int>> res;
        vector<int> out;
        vector<int> visited(num.size(), 0); // save visited states
        permuteDFS(num, 0, visited, out, res);
        return res;
    }
    void permuteDFS(vector<int> &num, int level, vector<int> &visited, vector<int> &out, vector<vector<int>> &res) {
        if (level == num.size()) res.push_back(out);
        else {
            for (int i = 0; i < num.size(); ++i) {
                if (visited[i] == 0) {
                    visited[i] = 1;
                    out.push_back(num[i]);
                    permuteDFS(num, level + 1, visited, out, res);
                    out.pop_back();
                    visited[i] = 0;
                }
            }
        }
    }
};

// 2. Use swap function
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
        permuteDFS(nums, 0, nums.size()-1, res);
        return res;
    }
    void permuteDFS(vector<int>& nums, int start, int end, vector<vector<int>> &res) {
        if (start > end) {
            res.push_back(nums);
            return;
        }
        for (int i = start; i <= end; ++i) {
            swap(nums[start], nums[i]);
            permuteDFS(nums, start+1, end, res);
            swap(nums[start], nums[i]);
        }
    }
};
\end{lstlisting}


\section{Permutations II (M)}
Given a collection of numbers that might contain duplicates, return all possible unique permutations.\\

For example, [1,1,2] have the following unique permutations:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
] \\

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int> &num) {
        vector<vector<int>> res;
        vector<int> out;
        vector<int> visited(num.size(), 0);
        sort(num.begin(), num.end());
        permuteUniqueDFS(num, 0, visited, out, res);
        return res;
    }
    void permuteUniqueDFS(vector<int> &num, int level, vector<int> &visited, vector<int> &out, vector<vector<int>> &res) {
        if (level >= num.size()) res.push_back(out);
        else {
            for (int i = 0; i < num.size(); ++i) {
                if (visited[i] == 0) {
                    // skip duplicates
                    if (i > 0 && num[i] == num[i-1] && visited[i-1] == 0) continue;
                    visited[i] = 1;
                    out.push_back(num[i]);
                    permuteUniqueDFS(num, level + 1, visited, out, res);
                    out.pop_back();
                    visited[i] = 0;
                }
            }
        }
    }
};

class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        permuteUniqueDFS(nums, 0, nums.size()-1, res);
        return res;
    }
    // Do not use reference of nums and do not swap back after recursion
    void permuteUniqueDFS(vector<int> nums, int start, int end, vector<vector<int>> &res) {
        if (start > end) {
            res.push_back(nums);
            return;
        }
        for (int i = start; i <= end; ++i) {
            if (i != start && nums[start] == nums[i]) continue;
            swap(nums[start], nums[i]);
            permuteUniqueDFS(nums, start+1, end, res);
        }
    }
};
\end{lstlisting}


\section{Next Permutation (M)}
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory.\\

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\\
1,2,3 $->$ 1,3,2\\
3,2,1 $->$ 1,2,3\\
1,1,5 $->$ 1,5,1\\

\begin{lstlisting}
// 1. Find the first num that is smaller than 7:
//      1   2#  7   4   3   1
// 2. Find the first num that is larger than 2:
//      1   2   7   4   3#  1
// 3. Swap 2 and 3:
//      1   3#  7   4   2#  1
// 4. Reverse the left numbers after 3: 
//      1   3   1#  2#  4#  7#
class Solution {
public:
    void nextPermutation(vector<int> &num) {
        int i, j, n = num.size();
        for (i = n - 2; i >= 0; --i) {
            if (num[i + 1] > num[i]) { // step 1
                for (j = n - 1; j >= i; --j) {
                    if (num[j] > num[i]) break; // step 2
                }
                swap(num[i], num[j]); // step 3
                reverse(num.begin() + i + 1, num.end()); // step 4
                return;
            }
        }
        reverse(num.begin(), num.end()); // reverse nums if no next permutation
    }
};
\end{lstlisting}


\section{Permutation Sequence (M)}
The set [1,2,3,...,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, We get the following sequence (i.e., for n = 3):
    "123"\\
    "132"\\
    "213"\\
    "231"\\
    "312"\\
    "321"\\
Given n and k, return the kth permutation sequence.\\
Note: Given n will be between 1 and 9 inclusive.\\

\begin{lstlisting}
class Solution {
public:
    string getPermutation(int n, int k) {
        string res;
        string num = "123456789";
        vector<int> f(n, 1);
        for (int i = 1; i < n; ++i) {
            f[i] = f[i - 1] * i; // compute 1!, 2!, ...
        }
        --k; // align index
        for (int i = n; i >= 1; --i) {
            int j = k / f[i - 1];
            k %= f[i - 1];
            res.push_back(num[j]);
            num.erase(j, 1);
        }
        return res;
    }
};
\end{lstlisting}


\section{Combinations (M)}
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.\\

For example, If n = 4 and k = 2, a solution is: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4]]\\

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> res;
        vector<int> out;
        if (k > n) return res;
        combineDFS(res, out, 1, n, k);
        return res;
    }
    void combineDFS(vector<vector<int>> &res, vector<int> &out, int start, int end, int k) {
        if (k == 0) res.push_back(out);
        for (int i = start; i <= end; ++i) {
            out.push_back(i);
            combineDFS(res, out, i+1, end, k-1);
            out.pop_back();
        }
    }
};
\end{lstlisting}


\section{Combination Sum (M)}
Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times.\\

Note:\\
    All numbers (including target) will be positive integers.\\
    The solution set must not contain duplicate combinations.\\

For example, given candidate set [2, 3, 6, 7] and target 7, A solution set is: [ [7], [2, 2, 3] ]\\

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> res;
        vector<int> out;
        sort(candidates.begin(), candidates.end());
        combinationSumDFS(candidates, target, out, res, 0);
        return res;
    }
    void combinationSumDFS(vector<int>& candidates, int target, vector<int>& out, vector<vector<int>> &res, int index) {
        if (target < 0) {
            return;
        } else if (target == 0) {
            res.push_back(out);
        } else {
            for (int i = index; i < candidates.size(); ++i) {
                out.push_back(candidates[i]);
                combinationSumDFS(candidates, target-candidates[i], out, res, i);
                out.pop_back();
            }
        }
    }
};
\end{lstlisting}


\section{Combination Sum II (M)}
Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination.\\

Note:\\
    All numbers (including target) will be positive integers.\\
    The solution set must not contain duplicate combinations.\\

For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] \\

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<vector<int>> res;
        vector<int> out;
        sort(candidates.begin(), candidates.end());
        combinationSum2DFS(candidates, target, out, res, 0);
        return res;        
    }
    void combinationSum2DFS(vector<int>& candidates, int target, vector<int>& out, vector<vector<int>> &res, int index) {
        if (target < 0) {
            return;
        } else if (target == 0) {
            res.push_back(out);
        } else {
            for (int i = index; i < candidates.size(); ++i) {
                if (i == index || candidates[i] != candidates[i-1]) { //skip duplicates
                    out.push_back(candidates[i]);
                    combinationSum2DFS(candidates, target-candidates[i], out, res, i+1);//update i to i+1
                    out.pop_back();
                }
            } 
        }
    }
};
\end{lstlisting}


\section{Combination Sum III (M)}
Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. \\

Example 1:\\
Input: k = 3, n = 7\\
Output: [[1,2,4]]\\

Example 2:\\
Input: k = 3, n = 9\\
Output:[[1,2,6], [1,3,5], [2,3,4]]\\

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> res;
        vector<int> out;
        combinationSum3DFS(k, n, out, res, 1);
        return res;
    }
    void combinationSum3DFS(int k, int n, vector<int>& out, vector<vector<int>> &res, int index) {
        if (n < 0) {
            return;
        } else if (k == 0 && n == 0) {
            res.push_back(out);
        } else {
            for (int i = index; i <= 9; ++i) {
                out.push_back(i);
                combinationSum3DFS(k-1, n-i, out, res, i+1);
                out.pop_back();
            }
        }
    }
};
\end{lstlisting}


\section{Factor Combinations (M)}
Numbers can be regarded as product of its factors. For example, 8 = 2 x 2 x 2 = 2 x 4.\\

Write a function that takes an integer n and return all possible combinations of its factors.\\

Note: \\
    Each combination's factors must be sorted ascending, for example: The factors of 2 and 6 is [2, 6], not [6, 2].\\
    You may assume that n is always positive.\\
    Factors should be greater than 1 and less than n.\\

Examples: \\
input: 1
output: 
[]\\

input: 37
output: 
[]\\

input: 12
output:
[
  [2, 6],
  [2, 2, 3],
  [3, 4]
]\\

input: 32
output:
[
  [2, 16],
  [2, 2, 8],
  [2, 2, 2, 4],
  [2, 2, 2, 2, 2],
  [2, 4, 4],
  [4, 8]
]\\

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> getFactors(int n) {
        vector<vector<int>> res;
        dfs(n, 2, {}, res);
        return res;
    }
    void dfs(int n, int start, vector<int> out, vector<vector<int>> &res) {
        if (n == 1) {
            if (out.size() > 1) res.push_back(out);
        } else {
            for (int i = start; i <= n; ++i) {
                if (n % i == 0) {
                    out.push_back(i);
                    dfs(n / i, i, out, res);
                    out.pop_back();
                }
            }
        }
    }
};
\end{lstlisting}


\section{Letter Combinations of a Phone Number (M)}
Given a digit string, return all possible letter combinations that the number could represent.\\

Input:Digit string "23"\\
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].\\

Note:Although the above answer is in lexicographical order, your answer could be in any order you want. \\

\begin{lstlisting}
class Solution(object):
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """
        if not digits: return []
        res = []
        d = {0:'', 1:'', 2:'abc', 3:'def', 4:'ghi', 5:'jkl',
             6:'mno', 7:'pqrs', 8:'tuv', 9:'wxyz'}
        self.combine(digits, d, 0, '', res)
        return res
    def combine(self, digits, d, idx, out, res):
        if idx == len(digits):
            res.append(out)
            return
        num = int(digits[idx])
        s = d[num]
        for i in range(len(s)):
            self.combine(digits, d, idx+1, out+s[i], res)
\end{lstlisting}

\begin{lstlisting}
// 1. Recursion
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        vector<string> res;
        if (digits.empty()) return res;
        string dict[] = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        letterCombinationsDFS(digits, dict, 0, "", res);
        return res;
    }
    void letterCombinationsDFS(string digits, string dict[], int level, string out, vector<string> &res) {
        if (level == digits.size()) res.push_back(out);
        else {
            string str = dict[digits[level] - '2'];
            for (int i = 0; i < str.size(); ++i) {
                out.push_back(str[i]);
                letterCombinationsDFS(digits, dict, level + 1, out, res);
                out.pop_back();
            }
        }
    }
};

// 2. Iterative
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        vector<string> res;
        if (digits.empty()) return res;
        string dict[] = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        res.push_back("");
        for (int i = 0; i < digits.size(); ++i) {
            int n = res.size();
            string str = dict[digits[i] - '2'];
            for (int j = 0; j < n; ++j) {
                string tmp = res.front();
                res.erase(res.begin());
                for (int k = 0; k < str.size(); ++k) {
                    res.push_back(tmp + str[k]);
                }
            }
        }
        return res;
    }
};

// 3. Iterative 2
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        vector<string> res;
        if (digits.empty()) return res;
        vector<string> str = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        res.push_back("");
        for (int i = 0; i < digits.size(); ++i) {
            vector<string> tmp;
            int index = digits[i] - '0';
            for (int j = 0; j < str[index].size(); ++j) {
                for (int k = 0; k < res.size(); ++k) {
                    tmp.push_back(res[k]+str[index][j]);
                }
            }
            res = tmp;
        }
        return res;
    }
};
\end{lstlisting}


\section{Walls and Gates (M)}
You are given a m x n 2D grid initialized with these three possible values.\\
    -1 - A wall or an obstacle.\\
    0 - A gate.\\
    INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.\\

Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.\\

For example, given the 2D grid:\\
INF  -1  0  INF\\
INF INF INF  -1\\
INF  -1 INF  -1\\
  0  -1 INF INF\\

After running your function, the 2D grid should be:\\
  3  -1   0   1\\
  2   2   1  -1\\
  1  -1   2  -1\\
  0  -1   3   4\\

\begin{lstlisting}
class Solution {
public:
    void wallsAndGates(vector<vector<int>>& rooms) {
        for (int i = 0; i < rooms.size(); ++i) {
            for (int j = 0; j < rooms[i].size(); ++j) {
                if (rooms[i][j] == 0) {
                    dfs(rooms, i, j, 0);
                }
            }
        }
    }
    void dfs(vector<vector<int>> &rooms, int i, int j, int val) {
        if (i < 0 || i >= rooms.size() || j < 0 || j >= rooms[i].size() || rooms[i][j] < val) return;
        rooms[i][j] = val;
        dfs(rooms, i + 1, j, val + 1);
        dfs(rooms, i - 1, j, val + 1);
        dfs(rooms, i, j + 1, val + 1);
        dfs(rooms, i, j - 1, val + 1);
    }
};
\end{lstlisting}


\section{Surrounded Regions (M)}
Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region.\\

For example,\\
X X X X\\
X O O X\\
X X O X\\
X O X X\\

After running your function, the board should be:\\
X X X X\\
X X X X\\
X X X X\\
X O X X\\

\begin{lstlisting}
class Solution {
public:
    void solve(vector<vector<char> >& board) {
        // if O exists on the most outside rows and columns of the board,
        // the O will never be surrounded by X
        for (int i = 0; i < board.size(); ++i) {
            for (int j = 0; j < board[i].size(); ++j) {
                if ((i == 0 || i == board.size() - 1 || j == 0 || j == board[i].size() - 1) 
                    && board[i][j] == 'O')
                    solveDFS(board, i, j);
            }
        }
        // flip all O to X, flip all N to O
        for (int i = 0; i < board.size(); ++i) {
            for (int j = 0; j < board[i].size(); ++j) {
                if (board[i][j] == 'O') board[i][j] = 'X';
                if (board[i][j] == 'N') board[i][j] = 'O';
            }
        }
    }
    // search if there are any O's connected to the current O
    // set all of them to N
    void solveDFS(vector<vector<char> > &board, int i, int j) {
        if (board[i][j] == 'O') {
            board[i][j] = 'N';
            if (i > 0 && board[i - 1][j] == 'O') 
                solveDFS(board, i - 1, j);
            if (i < board.size() - 1 && board[i + 1][j] == 'O') 
                solveDFS(board, i + 1, j);
            if (j > 1 && board[i][j - 1] == 'O') 
                solveDFS(board, i, j - 1);
            if (j < board[i].size() - 1 && board[i][j + 1] == 'O') 
                solveDFS(board, i, j + 1);
        }
    }
};
\end{lstlisting}


\section{Number of Islands (M)}
Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\\

Example 1:\\
11110\\
11010\\
11000\\
00000\\
Answer: 1\\

Example 2:\\
11000\\
11000\\
00100\\
00011\\
Answer: 3\\

\begin{lstlisting}
class Solution {
public:
    int numIslands(vector<vector<char> > &grid) {
        if (grid.empty() || grid[0].empty()) return 0;
        int m = grid.size(), n = grid[0].size(), res = 0;
        vector<vector<bool> > visited(m, vector<bool>(n, false));
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == '1' && !visited[i][j]) {
                    numIslandsDFS(grid, visited, i, j);
                    ++res;
                }
            }
        }
        return res;
    }
    void numIslandsDFS(vector<vector<char> > &grid, vector<vector<bool> > &visited, int x, int y) {
        if (x < 0 || x >= grid.size()) return;
        if (y < 0 || y >= grid[0].size()) return;
        if (grid[x][y] != '1' || visited[x][y]) return;
        visited[x][y] = true; // grid[x][y] is visited now
        // search other 4 direction of grid[x][y]
        numIslandsDFS(grid, visited, x - 1, y);
        numIslandsDFS(grid, visited, x + 1, y);
        numIslandsDFS(grid, visited, x, y - 1);
        numIslandsDFS(grid, visited, x, y + 1);
    }
};
\end{lstlisting}


\section{Number of Islands II (H)}
A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. \\

Example:\\
Given m = 3, n = 3, positions = [[0,0], [0,1], [1,2], [2,1]].\\

Initially, the 2d grid grid is filled with water. (Assume 0 represents water and 1 represents land).\\
0 0 0\\
0 0 0\\
0 0 0\\

Operation \#1: addLand(0, 0) turns the water at grid[0][0] into a land.\\
1 0 0\\
0 0 0   Number of islands = 1\\
0 0 0\\

Operation \#2: addLand(0, 1) turns the water at grid[0][1] into a land.\\
1 1 0\\
0 0 0   Number of islands = 1\\
0 0 0\\

Operation \#3: addLand(1, 2) turns the water at grid[1][2] into a land.\\
1 1 0\\
0 0 1   Number of islands = 2\\
0 0 0\\

Operation \#4: addLand(2, 1) turns the water at grid[2][1] into a land.\\
1 1 0\\
0 0 1   Number of islands = 3\\
0 1 0\\

We return the result as an array: [1, 1, 2, 3]\\

Challenge: Can you do it in time complexity O(k log mn), where k is the length of the positions?\\

\begin{lstlisting}
class Solution {
public:
    vector<int> numIslands2(int m, int n, vector<pair<int, int>>& positions) {
        vector<int> res;
        if (m <= 0 || n <= 0) return res;
        vector<int> roots(m * n, -1);
        int cnt = 0;
        vector<vector<int> > dirs{{0, -1}, {-1, 0}, {0, 1}, {1, 0}};
        for (auto a : positions) {
            int id = n * a.first + a.second;
            roots[id] = id;
            ++cnt;
            for (auto d : dirs) {
                int x = a.first + d[0], y = a.second + d[1];
                int cur_id = n * x + y;
                if (x < 0 || x >= m || y < 0 || y >= n || roots[cur_id] == -1) continue;
                int new_id = findRoots(roots, cur_id);
                if (id != new_id) {
                    roots[id] = new_id;
                    id = new_id;
                    --cnt;
                }
            }
            res.push_back(cnt);
        }
        return res;
    }
    int findRoots(vector<int> &roots, int id) {
        while (id != roots[id]) {
            roots[id] = roots[roots[id]];
            id = roots[id];
        }
        return id;
    }
};
\end{lstlisting}


\section{Word Search (M)}
Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

For example,
Given board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]\\

word = "ABCCED", returns true,\\
word = "SEE", returns true,\\
word = "ABCB", returns false.\\

\begin{lstlisting}
class Solution {
public:
    bool exist(vector<vector<char> > &board, string word) {
        if (word.empty()) return true;
        if (board.empty() || board[0].empty()) return false;
        vector<vector<bool> > visited(board.size(), vector<bool>(board[0].size(), false));
        for (int i = 0; i < board.size(); ++i) {
            for (int j = 0; j < board[i].size(); ++j) {
                if (search(board, word, 0, i, j, visited)) return true;
            }
        }
        return false;
    }
    bool search(vector<vector<char> > &board, string word, int idx, int i, int j, vector<vector<bool> > &visited) {
        if (idx == word.size()) return true;
        if (i < 0 || j < 0 || i >= board.size() || j >= board[0].size() || visited[i][j] || board[i][j] != word[idx]) return false;
        visited[i][j] = true;
        bool res = search(board, word, idx + 1, i - 1, j, visited) 
                 || search(board, word, idx + 1, i + 1, j, visited)
                 || search(board, word, idx + 1, i, j - 1, visited)
                 || search(board, word, idx + 1, i, j + 1, visited);
        visited[i][j] = false;
        return res;
    }
};
\end{lstlisting}


\section{Word Search II (H)}
Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

For example,
Given words = ["oath","pea","eat","rain"] and board =
[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]\\

Return ["eat","oath"].\\

Note:
You may assume that all inputs are consist of lowercase letters a-z.\\

You would need to optimize your backtracking to pass the larger test. Could you stop backtracking earlier?\\

If the current candidate does not exist in all words' prefix, you could stop backtracking immediately. What kind of data structure could answer such query efficiently? Does a hash table work? Why or why not? How about a Trie? If you would like to learn how to implement a basic trie, please work on this problem: Implement Trie (Prefix Tree) first.\\

\begin{lstlisting}
class Solution {
public:
    struct TrieNode {
        TrieNode *child[26];
        string str;
        TrieNode() : str("") {
            for (auto &a : child) a = NULL;
        }
    };
    struct Trie {
        TrieNode *root;
        Trie() : root(new TrieNode()) {}
        void insert(string s) {
            TrieNode *p = root;
            for (auto &a : s) {
                int i = a - 'a';
                if (!p->child[i]) p->child[i] = new TrieNode();
                p = p->child[i];
            }
            p->str = s;
        }
    };
    vector<string> findWords(vector<vector<char> >& board, vector<string>& words) {
        vector<string> res;
        if (words.empty() || board.empty() || board[0].empty()) return res;
        vector<vector<bool> > visit(board.size(), vector<bool>(board[0].size(), false));
        Trie T;
        for (auto &a : words) T.insert(a);
        for (int i = 0; i < board.size(); ++i) {
            for (int j = 0; j < board[i].size(); ++j) {
                if (T.root->child[board[i][j] - 'a']) {
                    search(board, T.root->child[board[i][j] - 'a'], i, j, visit, res);
                }
            }
        }
        return res;
    }
    void search(vector<vector<char> > &board, TrieNode *p, int i, int j, vector<vector<bool> > &visit, vector<string> &res) { 
        if (!p->str.empty()) {
            res.push_back(p->str);
            p->str.clear();
        }
        int d[][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        visit[i][j] = true;
        for (auto &a : d) {
            int nx = a[0] + i, ny = a[1] + j;
            if (nx >= 0 && nx < board.size() && ny >= 0 && ny < board[0].size() && !visit[nx][ny] && p->child[board[nx][ny] - 'a']) {
                search(board, p->child[board[nx][ny] - 'a'], nx, ny, visit, res);
            }
        }
        visit[i][j] = false;
    }
};
\end{lstlisting}








