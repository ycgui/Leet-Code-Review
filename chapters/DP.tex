\chapter{Dynamic Programming}


\section{Climbing Stairs (E)}
You are climbing a stair case. It takes n steps to reach to the top.\\

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? \\ 

\begin{lstlisting}
class Solution {
public:
    int climbStairs(int n) {
        vector<int> steps(n,0);
        steps[0] = 1;
        steps[1] = 2;
        // the number of distinct ways to reach level n is the sum of number of distinct ways to reach level n-1 and n-2.
        for(int i = 2; i < n; i++)
            steps[i] = steps[i-2] + steps[i-1]; 
        return steps[n-1];
    }
};
\end{lstlisting}


\section{Combination Sum IV (M)}
Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.\\

Example: nums = [1, 2, 3], target = 4\\
The possible combination ways are:\\
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)\\

Note that different sequences are counted as different combinations. Therefore the output is 7.\\

Follow up:\\
What if negative numbers are allowed in the given array?\\
How does it change the problem?\\
What limitation we need to add to the question to allow negative numbers? \\

\begin{lstlisting}
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target+1);
        dp[0] = 1;
        for (int i = 1; i <= target; ++i) {
            for (auto a : nums) {
                if (i >= a) dp[i] += dp[i-a];
            }
        }
        return dp.back();
    }
};
\end{lstlisting}


\section{Perfect Squares (M)}
Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.\\

For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9. \\

\begin{lstlisting}
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        
        // if x = a + b * b, the least number of perfect square numbers which sum to x is dp[x], then
        // case1: dp[x] = dp[a] + 1, because b * b is a perfect square number
        // case2: dp[x] = dp[a + b*b], because a + b * b is a perfect square number
        // dp[x] = min(case1, case2)
        for (int i = 0; i <= n; ++i) {
            for (int j = 1; i + j * j <= n; ++j) {
                dp[i + j * j] = min(dp[i + j * j], dp[i] + 1);
            }
        }
        return dp[n];
    }
};
\end{lstlisting}


\section{Best Time to Buy and Sell Stock (E)}
Say you have an array for which the i-th element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.\\

\begin{lstlisting}
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.empty() || prices.size() < 2)
            return 0;
        
        int profit = 0;
        int low = prices[0];
        
        for (int i = 1; i < prices.size(); ++i) {
            profit = max(profit, prices[i] - low);
            low = min(low, prices[i]);
        }
        
        return profit;
    }
};
\end{lstlisting}


\section{Best Time to Buy and Sell Stock II (M)}
Say you have an array for which the i-th element is the price of a given stock on day i. \\

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). \\

\begin{lstlisting}
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.empty() || prices.size() < 2)
            return 0;
        
        int profit = 0;
        int diff;
        
        for (int i = 1; i < prices.size(); ++i) {
            diff = prices[i] - prices[i-1];
            if (diff > 0)
                profit += diff;
        }
        
        return profit;
    }
};
\end{lstlisting}


\section{Best Time to Buy and Sell Stock with Cooldown (M)}
Say you have an array for which the i-th element is the price of a given stock on day i.\\

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:\\

    You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\\
    After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)\\


\begin{lstlisting}
class Solution {
public:
    int maxProfit(vector<int>& prices) {

        int buy = INT_MIN, sell = 0, rest = INT_MIN, cooldown = 0;
        
        for (int i = 0; i < prices.size(); ++i) {
            rest = max(rest, buy);
            buy = cooldown - prices[i];
            cooldown = max(sell, cooldown);
            sell = rest + prices[i];
        }
        
        return max(cooldown, sell);
    }
};
\end{lstlisting}


\section{Best Time to Buy and Sell Stock III (H)}
Say you have an array for which the i-th element is the price of a given stock on day i. \\

Design an algorithm to find the maximum profit. You may complete at most two transactions. However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). \\

\begin{lstlisting}
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.empty() || prices.size() < 2)
            return 0;
        
        vector<int> profit(prices.size());
        
        // compute the forward max profit and save it
        int buy = prices[0];
        profit[0] = 0;
        for (int i = 1; i < prices.size(); i++) {
            profit[i] = max(profit[i - 1], prices[i] - buy);
            buy = min(buy, prices[i]);
        }
        
        // The final max profit is the sum of max profit before day i (profit[i]) and after day i (sell - prices[i])
        int sell = prices[prices.size() - 1];
        int best = 0;
        for (int i = prices.size() - 2; i >= 0; i--) {
            best = max(best, sell - prices[i] + profit[i]);
            sell = max(sell, prices[i]);
        }
        
        return best;   
    }
};
\end{lstlisting}


\section{Best Time to Buy and Sell Stock IV (H)}
Say you have an array for which the i-th element is the price of a given stock on day i. \\

Design an algorithm to find the maximum profit. You may complete at most k transactions. However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). \\

\begin{lstlisting}
class Solution {
public:
    int maxProfit(int k, vector<int> &prices) {
        if (prices.empty() || prices.size() < 2) 
            return 0;
        if (k >= prices.size()) 
            return solveMaxProfit(prices);
        
        int global[k + 1] = {0};
        int local[k + 1] = {0};
        for (int i = 0; i < prices.size() - 1; ++i) {
            int diff = prices[i + 1] - prices[i];
            for (int j = k; j >= 1; --j) {
                local[j] = max(global[j - 1] + max(diff, 0), local[j] + diff);
                global[j] = max(global[j], local[j]);
            }
        }
        return global[k];
    }
    
    int solveMaxProfit(vector<int> &prices) {
        int profit = 0;
        for (int i = 1; i < prices.size(); ++i) {
            if (prices[i] > prices[i - 1]) {
                profit += prices[i] - prices[i - 1];
            }
        }
        return profit;
    }
};
\end{lstlisting}


\section{House Robber (E)}
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. \\

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. \\

\begin{lstlisting}
class Solution {
public:
    int rob(vector<int>& nums) {
        int cur_rob = 0, prev_rob = 0, sum = 0;
        
        for (int i = 0; i < nums.size(); ++i) {
            cur_rob = prev_rob + nums[i];
            prev_rob = sum;
            sum = max(cur_rob, prev_rob);
        }
        
        return sum;
    }
};
\end{lstlisting}


\section{House Robber II (M)}
After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street. \\

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\\

\begin{lstlisting}
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        if (n == 1) return nums[0];
        return max(rob(nums, 0, n-2), rob(nums, 1, n-1));     // can not rob nums[0] and nums[n-1] together
    }
    
    int rob(vector<int> &nums, int start, int end) {
        int cur_rob = 0, prev_rob = 0, sum = 0;
        
        for (int i = start; i <= end; ++i) {
            cur_rob = prev_rob + nums[i];
            prev_rob = sum;
            sum = max(cur_rob, prev_rob);
        }
        
        return sum;
    }
};
\end{lstlisting}


\section{House Robber III (M)}
The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the "root." Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that "all houses in this place forms a binary tree". It will automatically contact the police if two directly-linked houses were broken into on the same night. \\

Determine the maximum amount of money the thief can rob tonight without alerting the police. \\

\begin{lstlisting}
class Solution {
public:
    int rob(TreeNode *root) {
        vector<int> res = robber(root);
        return max(res[0], res[1]);
    }
    
    vector<int> robber(TreeNode *root) {
        vector<int> res(2,0);
        if (!root)  return res;
        
        vector<int> left = robber(root->left);
        vector<int> right = robber(root->right);
        
        res[0] = max(left[0], left[1]) + max(right[0], right[1]);   // if root is not robbed
        res[1] = root->val + left[0] + right[0];                    // if root is robbed
        
        return res;
    }
};
\end{lstlisting}


\section{Paint Fence (E)}
There is a fence with n posts, each post can be painted with one of the k colors. You have to paint all the posts such that no more than two adjacent fence posts have the same color. Return the total number of ways you can paint the fence.\\

Note: n and k are non-negative integers.\\

\begin{lstlisting}
class Solution {
public:
    int numWays(int n, int k) {
        if (n == 0) return 0;
        if (n == 1) return k;
        vector<int> dp(n);
        
        dp[0] = k;                          // n = 1, k ways to paint
        dp[1] = k * (k - 1) + k;            // n = 2, diff color: k*(k-1) ways + same color: k ways
        
        /** 1. If the color of the current post i is different from the color of the last post i-1,
         *      then there are dp[i] = dp[i - 1] * (k - 1) ways to paint the current post i
         *  2. If the color of the current post i is same as the color of the last post i-1,
         *      then the color of the post i and i-1 must be different from the color of the second last post i-2
         *      so there are dp[i] = dp[i - 2] * (k - 1) * 1 ways to paint the current post i  
         *  3. The total num of ways is a combination of case 1 and 2
         */
        for (int i = 2; i < n; i++) {
            dp[i] = dp[i - 1] * (k - 1) + dp[i - 2] * (k - 1);
        }
        
        return dp[n - 1];
    }
};
\end{lstlisting}


\section{Paint House (M)}
There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\\

The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses.\\

Note:
All costs are positive integers.\\

\begin{lstlisting}
class Solution {
public:
    int minCost(vector<vector<int>> &cost) {
        if (cost.empty() || cost[0].empty())    return 0;
        vector<vector<int>> dp = costs;
        for (int i = 1; i < dp.size(); ++i) {
            // dp[i][0] += min(dp[i - 1][1], dp[i - 1][2]);
            // dp[i][1] += min(dp[i - 1][0], dp[i - 1][2]);
            // dp[i][2] += min(dp[i - 1][0], dp[i - 1][1]);
            for (int j = 0; j < 3; ++j) {
                dp[i][j] += min(dp[i-1][(j+1)%3], dp[i-1][(j+2)%3]);
            }
        }
        return min(min(dp.back()[0], dp.back()[1]), dp.back()[2]);
    }
};
\end{lstlisting}


\section{Paint House II (H)}
There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\\

The cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2]is the cost of painting house 1 with color 2, and so on... Find the minimum cost to paint all houses.\\

Note:
All costs are positive integers.\\

Follow up:
Could you solve it in O(nk) runtime?\\

\begin{lstlisting}
class Solution {
public:
    int minCostII(vector<vector<int>>& costs) {
        if(costs.empty() || costs[0].empty())   return 0;
        int n = costs.size(), k = costs[0].size(), res = INT_MAX;
        vector<vector<int>> dp = costs;
        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < k; ++j) {
                int tmp = INT_MAX;
                // find the local min cost of using other color to paint the last house
                for (int d = 1; d < k; ++d) {
                    tmp = min(tmp, dp[i-1][(j+d)%k]);
                }
                dp[i][j] += tmp;
                // find the global min cost of painting all houses
                if (i == n-1) {
                    res = min(res, dp[i][j]);
                }
            }
        }
        return res;
    }
};

class Solution {
public:
    int minCostII(vector<vector<int>>& costs) {
        if (costs.empty() || costs[0].empty()) return 0;
        vector<vector<int>> dp = costs;
        int min1 = -1, min2 = -1;
        for (int i = 0; i < dp.size(); ++i) {
            int last1 = min1, last2 = min2;
            min1 = -1; min2 = -1;
            for (int j = 0; j < dp[i].size(); ++j) {
                if (j != last1) {
                    dp[i][j] += last1 < 0 ? 0 : dp[i - 1][last1];
                } else {
                    dp[i][j] += last2 < 0 ? 0 : dp[i - 1][last2];
                }
                if (min1 < 0 || dp[i][j] < dp[i][min1]) {
                    min2 = min1; min1 = j;
                } else if (min2 < 0 || dp[i][j] < dp[i][min2]) {
                    min2 = j;
                }
            }
        }
        return dp.back()[min1];
    }
};
\end{lstlisting}


\section{Pascal's Triangle (E)}
Given numRows, generate the first numRows of Pascal's triangle. \\

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> res;
        if (numRows == 0)   return res;
        
        res.push_back(vector<int> (1,1));               // first row
        
        for (int i = 2; i <= numRows; ++i) {
            vector<int> cur(i,1);                       // generate next row with all 1s
            for (int j = 1; j < i-1; ++j)               // update elements from the 2nd to the (i-1)-th 
                cur[j] = res[i-2][j-1] + res[i-2][j];
            res.push_back(cur);
        }
        
        return res;
    }
};
\end{lstlisting}


\section{Pascal's Triangle II (E)}
Given an index k, return the k-th row of the Pascal's triangle. \\

\begin{lstlisting}
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> res;
        
        for (int i = 0; i <= rowIndex; ++i) {
            for (int j = i - 1; j > 0; --j) {
                res[j] = res[j-1] + res[j];     // scrolling array
            }
            res.push_back(1);
        }
        
        return res;
    }
};
\end{lstlisting}


\section{Range Sum Query - Immutable (E)}
Given an integer array nums, find the sum of the elements between indices i and j (i $\leq$ j), inclusive.\\

Example: \\
Given nums = [-2, 0, 3, -5, 2, -1]\\
sumRange(0, 2) = 1\\
sumRange(2, 5) = -1\\
sumRange(0, 5) = -3\\

Note:\\
    You may assume that the array does not change.\\
    There are many calls to sumRange function.\\

\begin{lstlisting}
// Your NumArray object will be instantiated and called as such:
// NumArray numArray(nums);
// numArray.sumRange(0, 1);
// numArray.sumRange(1, 2);

class NumArray {
public:
    vector<int> sums = {0};             // save an initial 0 into sums
    
    NumArray(vector<int> &nums) {       // class constructor
        int sum = 0;
        for (int i = 0; i < nums.size(); ++i) {
            sum += nums[i];
            sums.push_back(sum);        // sums[] contains nums.size() + 1 elements
        }
    }
    
    int sumRange(int i, int j) {
        return sums[j+1] - sums[i];     // get the correct sum by considering the offset in sums[]
    }
};
\end{lstlisting}


\section{Range Sum Query - Mutable (M)}
Given an integer array nums, find the sum of the elements between indices i and j (i $\leq$ j), inclusive. The update(i, val) function modifies nums by updating the element at index i to val. \\

Example: \\
Given nums = [1, 3, 5]
sumRange(0, 2) = 9
update(1, 2)
sumRange(0, 2) = 8

Note:\\
    The array is only modifiable by the update function.\\
    You may assume the number of calls to update and sumRange function is distributed evenly.\\

\begin{lstlisting}
struct SegmentTreeNode {
    int start, end, sum;
    SegmentTreeNode* left;
    SegmentTreeNode* right;
    SegmentTreeNode(int a, int b):start(a),end(b),sum(0),left(nullptr),right(nullptr){}
};
class NumArray {
    SegmentTreeNode* root;
public:
    NumArray(vector<int> &nums) {
        int n = nums.size();
        root = buildTree(nums,0,n-1);
    }
   
    void update(int i, int val) {
        modifyTree(i,val,root);
    }

    int sumRange(int i, int j) {
        return queryTree(i, j, root);
    }
    SegmentTreeNode* buildTree(vector<int> &nums, int start, int end) {
        if(start > end) return nullptr;
        SegmentTreeNode* root = new SegmentTreeNode(start,end);
        if(start == end) {
            root->sum = nums[start];
            return root;
        }
        int mid = start + (end - start) / 2;
        root->left = buildTree(nums,start,mid);
        root->right = buildTree(nums,mid+1,end);
        root->sum = root->left->sum + root->right->sum;
        return root;
    }
    int modifyTree(int i, int val, SegmentTreeNode* root) {
        if(root == nullptr) return 0;
        int diff;
        if(root->start == i && root->end == i) {
            diff = val - root->sum;
            root->sum = val;
            return diff;
        }
        int mid = (root->start + root->end) / 2;
        if(i > mid) {
            diff = modifyTree(i,val,root->right);
        } else {
            diff = modifyTree(i,val,root->left);
        }
        root->sum = root->sum + diff;
        return diff;
    }
    int queryTree(int i, int j, SegmentTreeNode* root) {
        if(root == nullptr) return 0;
        if(root->start == i && root->end == j) return root->sum;
        int mid = (root->start + root->end) / 2;
        if(i > mid) return queryTree(i,j,root->right);
        if(j <= mid) return queryTree(i,j,root->left);
        return queryTree(i,mid,root->left) + queryTree(mid+1,j,root->right);
    }
};


// Your NumArray object will be instantiated and called as such:
// NumArray numArray(nums);
// numArray.sumRange(0, 1);
// numArray.update(1, 10);
// numArray.sumRange(1, 2);
\end{lstlisting}


\section{Range Sum Query 2D - Immutable (M)}
Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). \\

Example:\\
Given matrix = [
  [3, 0, 1, 4, 2], 
  [5, 6, 3, 2, 1], 
  [1, 2, 0, 1, 5], 
  [4, 1, 0, 1, 7], 
  [1, 0, 3, 0, 5] 
]\\
sumRegion(2, 1, 4, 3) = 8\\
sumRegion(1, 1, 2, 2) = 11\\
sumRegion(1, 2, 2, 4) = 12\

Note:\\
    You may assume that the matrix does not change.\\
    There are many calls to sumRegion function.\\
    You may assume that row1 $\leq$ row2 and col1 $\leq$ col2.\\


\begin{lstlisting}
class NumMatrix {
public:
    int row, col;
    vector<vector<int>> sums;
    
    NumMatrix(vector<vector<int>> &matrix) {
        row = matrix.size();
        col = row > 0 ? matrix[0].size() : 0;
        sums = vector<vector<int>>(row+1, vector<int>(col+1, 0));
        for(int i = 1; i <= row; i++) {
            for(int j = 1; j <= col; j++) {
                sums[i][j] = sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1] + matrix[i-1][j-1];
            }
        }
    }

    int sumRegion(int row1, int col1, int row2, int col2) {
        return sums[row2+1][col2+1] - sums[row2+1][col1] - sums[row1][col2+1] + sums[row1][col1];
    }
};

// Your NumMatrix object will be instantiated and called as such:
// NumMatrix numMatrix(matrix);
// numMatrix.sumRegion(0, 1, 2, 3);
// numMatrix.sumRegion(1, 2, 3, 4);
\end{lstlisting}


\section{Unique Paths (M)}
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there?\\

Note: m and n will be at most 100.\\

\begin{lstlisting}
// 1. 2D DP solution
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n,1));
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};

// 2. 1D DP solution
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n,1);
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                dp[j] = dp[j] + dp[j-1]; //
            }
        }
        return dp[n-1];
    }
};
\end{lstlisting}


\section{Unique Paths II (M)}
Follow up for "Unique Paths":

Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid.\\

For example, There is one obstacle in the middle of a 3x3 grid as illustrated below.
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
], The total number of unique paths is 2.\\

Note: m and n will be at most 100.\\

\begin{lstlisting}
// 1. 2D DP
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        if (obstacleGrid.empty() || obstacleGrid[0].empty()) return 0;
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        if (obstacleGrid[0][0] == 1 || obstacleGrid[m-1][n-1] == 1) return 0;
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (obstacleGrid[i][j] == 1) {
                    dp[i][j] = 0;
                } else if (i == 0 && j == 0) {
                    dp[i][j] = 1;
                } else if (i == 0 && j > 0) {
                    dp[i][j] = dp[i][j-1];
                } else if (i > 0 && j == 0) {
                    dp[i][j] = dp[i-1][j];
                } else {
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }
            }
        }
        return dp[m-1][n-1];
    }
};

// 2. 1D DP
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        if (obstacleGrid.empty() || obstacleGrid[0].empty()) return 0;
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        if (obstacleGrid[0][0] == 1 || obstacleGrid[m-1][n-1] == 1) return 0;
        vector<int> dp(n, 0);
        dp[0] = 1;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (obstacleGrid[i][j] == 1) {
                    dp[j] = 0;
                } else if (j > 0) {
                    dp[j] = dp[j] + dp[j-1];
                }
            }
        }
        return dp[n-1];
    }
};
\end{lstlisting}


\section{Minimum Path Sum (M)}
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\\

Note: You can only move either down or right at any point in time.\\

\begin{lstlisting}
// 1. 2D DP
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        if (grid.size() == 0 || grid[0].size() == 0) return 0;
        int m = grid.size(), n = grid[0].size();
        int dp[m][n];
        // initializing
        dp[0][0] = grid[0][0];
        for (int i = 1; i < m; ++i) dp[i][0] = dp[i-1][0] + grid[i][0];
        for (int j = 1; j < n; ++j) dp[0][j] = dp[0][j-1] + grid[0][j];
        // get min
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]);
            }
        }    
        return dp[m-1][n-1];
    }
};

// 2. 1D DP
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        if (grid.size() == 0 || grid[0].size() == 0) return 0;
        int m = grid.size(), n = grid[0].size();
        int dp[n];
        dp[0] = grid[0][0];
        for (int i = 1; i < n; ++i) dp[i] = dp[i-1] + grid[0][i];
        for (int i = 1; i < m; ++i) {
            dp[0] += grid[i][0]; // need to update dp[0] for each row
            for (int j = 1; j < n; ++j) {
                dp[j] = grid[i][j] + min(dp[j-1], dp[j]);
            }
        }
        return dp[n-1];
    }
};
\end{lstlisting}


\section{Dungeon Game (M)}
The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. \\

The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers).\\

In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Write a function to determine the knight's minimum initial health so that he is able to rescue the princess.\\

Notes:\\
    The knight's health has no upper bound.\\
    Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.\\

\begin{lstlisting}
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        int m = dungeon.size(), n = dungeon[0].size();
        int dp[m][n];
        // Initialize K's health as K has to be alive when K reaches P
        // 1. If the current room can increase K's HP, 
        // then the minimum HP for K to reach the room is 1
        // 2. If the current room can reduce K's HP,
        // then the minimum HP for K to reach the room must be 1 - damage
        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1]);
        // initializing the last column
        for (int i = m - 2; i >= 0; --i) {
            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1]); 
        }
        // initializing the last row
        for (int j = n - 2; j >= 0; --j) {
            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j]); 
        }
        for (int i = m - 2; i >= 0; --i) {
            for (int j = n - 2; j >= 0; --j) {
                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]);
            }
        }
        return dp[0][0];
    }
};
\end{lstlisting}


\section{Increasing Triplet Subsequence (M)}
Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.\\

Formally the function should:\\
    Return true if there exists i, j, k\\
    such that $arr[i] < arr[j] < arr[k]$ given $0 \leq i < j < k \leq n-1$ else return false. \\

Your algorithm should run in O(n) time complexity and O(1) space complexity.\\

Examples:\\
Given [1, 2, 3, 4, 5],
return true.\\
Given [5, 4, 3, 2, 1],
return false. \\

\begin{lstlisting}
// 1. DP solution: Time O(N^2), Space O(N)
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        vector<int> dp(nums.size(), 1);
        for (int i = 0; i < nums.size(); ++i) {
            for (int j = 0; j < i; ++j) {
                if (nums[j] < nums[i]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                    if (dp[i] == 3) return true;
                }
            }
        }
        return false;
    }
};

// 2. Two minimum values: Time O(N), Space O(1)
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int c1 = INT_MAX, c2 = INT_MAX;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] <= c1) c1 = nums[i]; // the first minimum
            else if (nums[i] <= c2) c2 = nums[i]; // the second minimum
            else return true; // the third value
        }
        return false;
    }
};
\end{lstlisting}


\section{Longest Increasing Subsequence (M)}
Given an unsorted array of integers, find the length of longest increasing subsequence.\\

For example,
Given [10, 9, 2, 5, 3, 7, 101, 18],
The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.\\

Your algorithm should run in O(n2) complexity.\\

Follow up: Could you improve it to O(n log n) time complexity? \\

\begin{lstlisting}
// 1. DP solution: Time O(N^2), Space O(N)
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> dp(nums.size(), 1);
        int res = 0;
        for (int i = 0; i < nums.size(); ++i) {
            for (int j = 0; j < i; ++j) {
                if (nums[j] < nums[i]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            res = max(res, dp[i]);
        }
        return res;
    }
};

// 2. Binary search: Time O(NlogN), Space O(N)
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if (nums.empty()) return 0;
        vector<int> res = {nums[0]};
        for (int i = 1; i < nums.size(); ++i) {
            if (nums[i] < res[0]) { // update minimum
                res[0] = nums[i];
            } else if (nums[i] > res.back()) { // update maximum
                res.push_back(nums[i]);
            } else { // find values between the first and the last element of res and add them into res
                int left = 0, right = res.size() - 1;
                while (left < right) {
                    int mid = left + (right - left) / 2;
                    if (res[mid] < nums[i]) left = mid + 1;
                    else right = mid;
                }
                res[right] = nums[i];
            }
        }
        return res.size(); // the res size is the length of LIS
    }
};
\end{lstlisting}


\section{Longest Increasing Path in a Matrix (M)}
Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).\\

Example 1:\\
nums = [
  [9,9,4],
  [6,6,8],
  [2,1,1]
],
Return 4,
The longest increasing path is [1, 2, 6, 9].\\

Example 2:\\
nums = [
  [3,4,5],
  [3,2,6],
  [2,2,1]
],
Return 4,
The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\\

\begin{lstlisting}
class Solution {
public:
    int longestIncreasingPath(vector<vector<int> >& matrix) {
        if (matrix.empty() || matrix[0].empty()) return 0;
        int res = 1, m = matrix.size(), n = matrix[0].size();
        vector<vector<int> > dp(m, vector<int>(n, 0));
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                res = max(res, dfs(matrix, dp, i, j));
            }
        }
        return res;
    }
    int dfs(vector<vector<int> > &matrix, vector<vector<int> > &dp, int i, int j) {
        if (dp[i][j]) return dp[i][j];
        // move left, up, right, down
        vector<vector<int> > dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}}; 
        int max_len = 1, m = matrix.size(), n = matrix[0].size();
        for (auto a : dirs) {
            int x = i + a[0], y = j + a[1]; // move (i,j) to next cell
            // avoid corner cases, look for the increasing path
            if (x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] <= matrix[i][j]) continue;
            int len = 1 + dfs(matrix, dp, x, y);
            max_len = max(max_len, len);
        }
        dp[i][j] = max_len;
        return max_len;
    }
};
\end{lstlisting}


