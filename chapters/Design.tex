\chapter{Design and Implementation}
\section{Valid Sudoku (E)}
Determine if a Sudoku is valid, according to:\\
1. Each row must have the numbers 1-9 occuring just once. \\
2. Each column must have the numbers 1-9 occuring just once. \\
3. And the numbers 1-9 must occur just once in each of the 9 sub-boxes of the grid. \\

The Sudoku board could be partially filled, where empty cells are filled with the character '.'.  A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated. \\

\begin{lstlisting}
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        bool used[9]; // count if the number in the cell is appeared

        for (int i = 0; i < 9; ++i) {

            // fill: Assigns val to all the elements in the range [first,last).
            // all set to false (not appear)
            fill(used, used + 9, false);
            // check rows
            for (int j = 0; j < 9; ++j) { 
                if (!check(board[i][j], used))
                    return false;
            }

            fill(used, used + 9, false);
            // check columns
            for (int j = 0; j < 9; ++j) {               
                if (!check(board[j][i], used))
                return false;
            }
        }
        
        // check 9 blocks
        for (int m = 0; m < 3; ++m) {                   
            for (int n = 0; n < 3; ++n) {
                fill(used, used + 9, false);
                for (int i = m * 3; i < m * 3 + 3; ++i) {
                    for (int j = n * 3; j < n * 3 + 3; ++j) {
                        if (!check(board[i][j], used))
                            return false;
                    }
                }
            }
        }
        
        return true;
    }
    
    bool check(char ch, bool used[9]) {
        if (ch == '.')      return true; // continue if the current cell is .
        if (used[ch - '1']) return false; // not first time appear, return false
        return used[ch - '1'] = true; // first time appear, return true
    }
};
\end{lstlisting}


\section{Sudoku Solver (H)}
Write a program to solve a Sudoku puzzle by filling the empty cells. Empty cells are indicated by the character '.'. You may assume that there will be only one unique solution. \\

\begin{lstlisting}
class Solution {
public:
    bool solveSudoku(vector<vector<char> > &board) {
        for (int i = 0; i < 9; ++i) {
            for (int j = 0; j < 9; ++j) {
                if (board[i][j] == '.') {
                    for (int k = 0; k < 9; ++k) {
                        board[i][j] = '1' + k;
                        if (isValid(board, i, j) && solveSudoku(board))
                            return true;
                        board[i][j] = '.';
                    }
                    return false;
                }
            }
        }
        return true;
    }

    bool isValid(const vector<vector<char> > &board, int x, int y) {
        int i, j;
        for (i = 0; i < 9; i++) {  
              if (i != x && board[i][y] == board[x][y])
                  return false;
        }
        for (j = 0; j < 9; j++) {  
                if (j != y && board[x][j] == board[x][y])
                  return false;
        }
        for (i = 3 * (x / 3); i < 3 * (x / 3 + 1); i++) {
            for (j = 3 * (y / 3); j < 3 * (y / 3 + 1); j++) {
                if ((i != x || j != y) && board[i][j] == board[x][y])
                    return false;
            }
        }
        return true;
    }
};
\end{lstlisting}


\section{Boom Enemy (M)}
Given a 2D grid, each cell is either a wall 'W', an enemy 'E' or empty '0' (the number zero), return the maximum enemies you can kill using one bomb.
The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since the wall is too strong to be destroyed.
Note that you can only put the bomb at an empty cell.\\

Example:\\
For the given grid\\
0 E 0 0\\
E 0 W E\\
0 E 0 0\\
return 3. (Placing a bomb at (1,1) kills 3 enemies)\\

\begin{lstlisting}
class Solution {
public:
    int maxKilledEnemies(vector<vector<char>>& grid) {
        if (grid.empty() || grid[0].empty()) return 0;
        int m = grid.size(), n = grid[0].size(), res = 0, tmp;
        vector<vector<int>> v1(m, vector<int>(n, 0)), v2 = v1, v3 = v1, v4 = v1;
        // search each row
        for (int i = 0; i < m; ++i) { 
            for (int j = 0; j < n; ++j) { // from left to right
                if (j == 0 || grid[i][j] == 'W') tmp = 0;
                else tmp = v1[i][j-1];
                if (grid[i][j] == 'E') v1[i][j] = tmp + 1;
                else v1[i][j] = tmp;
            }
            for (int j = n - 1; j >= 0; --j) { // from right to left
                if (j == n - 1 || grid[i][j] == 'W') tmp = 0;
                else tmp = v2[i][j+1];
                if (grid[i][j] == 'E') v2[i][j] = tmp + 1;
                else v2[i][j] = tmp;
            }
        }
        // search each column
        for (int j = 0; j < n; ++j) { 
            for (int i = 0; i < m; ++i) { // from up to bottom
                if (i == 0 || grid[i][j] == 'W') tmp = 0;
                else tmp = v3[i-1][j];
                if (grid[i][j] == 'E') v3[i][j] = tmp + 1;
                else v3[i][j] = tmp;
            }
            for (int i = m - 1; i >= 0; --i) { // from bottom to up
                if (i == m - 1 || grid[i][j] == 'W') tmp = 0;
                else tmp = v4[i+1][j];
                if (grid[i][j] == 'E') v4[i][j] = tmp + 1;
                else v4[i][j] = tmp;
            }
        }
        // iterate all empty cell and get the max 
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == '0') {
                    res = max(res, v1[i][j] + v2[i][j] + v3[i][j] + v4[i][j]);
                }
            }
        }
        return res;
    }
};
\end{lstlisting}


\section{Android Unlock Patterns (M)}
Given an Android 3x3 key lock screen and two integers m and n, where $1 \leq m \leq n \leq 9$, count the total number of unlock patterns of the Android lock screen, which consist of minimum of m keys and maximum n keys.\\

Rules for a valid pattern:\\
    Each pattern must connect at least m keys and at most n keys.\\
    All the keys must be distinct.\\
    If the line connecting two consecutive keys in the pattern passes through any other keys, the other keys must have previously selected in the pattern. No jumps through non selected key is allowed.\\
    The order of keys used matters.\\

\begin{lstlisting}
class Solution {
public:
    int numberOfPatterns(int m, int n) {
        int res = 0;
        vector<bool> visited(10, false);
        vector<vector<int>> jumps(10, vector<int>(10, 0));
        jumps[1][3] = jumps[3][1] = 2;
        jumps[4][6] = jumps[6][4] = 5;
        jumps[7][9] = jumps[9][7] = 8;
        jumps[1][7] = jumps[7][1] = 4;
        jumps[2][8] = jumps[8][2] = 5;
        jumps[3][9] = jumps[9][3] = 6;
        jumps[1][9] = jumps[9][1] = jumps[3][7] = jumps[7][3] = 5;
        res += helper(1, 1, 0, m, n, jumps, visited) * 4;
        res += helper(2, 1, 0, m, n, jumps, visited) * 4;
        res += helper(5, 1, 0, m, n, jumps, visited);
        return res;
    }
    int helper(int num, int len, int res, int m, int n, vector<vector<int>> &jumps, vector<bool> &visited) {
        if (len >= m) ++res;
        ++len;
        if (len > n) return res;
        visited[num] = true;
        for (int next = 1; next <= 9; ++next) {
            int jump = jumps[num][next];
            if (!visited[next] && (jump == 0 || visited[jump])) {
                res = helper(next, len, res, m, n, jumps, visited);
            }
        }
        visited[num] = false;
        return res;
    }
};
\end{lstlisting}


\section{Game of Life (M)}
According to the Wikipedia's article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970." Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\\

    Any live cell with fewer than two live neighbors dies, as if caused by under-population.\\
    Any live cell with two or three live neighbors lives on to the next generation.\\
    Any live cell with more than three live neighbors dies, as if by over-population.\\
    Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\\

Write a function to compute the next state (after one update) of the board given its current state.\\

Follow up:\\
    Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.\\
    In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?\\
    
\begin{lstlisting}
/** [2nd bit, 1st bit] = [next state, current state]
 * 00  dead (next) <- dead (current)
 * 01  dead (next) <- live (current)  
 * 10  live (next) <- dead (current)  
 * 11  live (next) <- live (current) 
 * 
 * 1. In the beginning, every cell is either 00 or 01.
 * 2. Notice that 1st state is independent of 2nd state.
 * 3. Imagine all cells are instantly changing from the 1st to the 2nd state, at the same time.
 * 4. Let's count # of neighbors from 1st state and set 2nd state bit.
 * 5. Since every 2nd state is by default dead, no need to consider transition 01 -> 00.
 * 6. In the end, delete every cell's 1st state by doing >> 1.
 * 
 * For each cell's 1st bit, check the 8 pixels around itself, and set the cell's 2nd bit.
    Transition 01 -> 11: when board == 1 and (lives == 2 || lives == 3).
    Transition 00 -> 10: when board == 0 and lives == 3.
 * To get the current state, simply do board[i][j] & 1
 * To get the next state, simply do board[i][j] >> 1
 */
class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {
        if (board.empty() || board.size() == 0) return;
        int m = board.size(), n = board[0].size();
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                int lives = getLives(board, i, j, m, n); // get current live numbers
                if (board[i][j] == 1 && (lives == 2 || lives == 3)) {
                    board[i][j] = 3;            // 01 -> 11
                }
                
                if (board[i][j] == 0 && lives == 3) {
                    board[i][j] = 2;            // 00 -> 10
                }
            }
        }
        // update board based on the 2nd bit
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                board[i][j] >>= 1; // get the 2nd bit
            }
        }
    }
    int getLives(vector<vector<int>>& board, int i, int j, int m, int n) {
        int lives = 0;
        for (int p = max(i-1, 0); p <= min(i+1, m-1); ++p) {
            for (int q = max(j-1, 0); q <= min(j+1, n-1); ++q) {
                lives += board[p][q] & 1;       // add the 1st bit
            }
        }
        lives -= board[i][j] & 1;               // remove (i,j) itself
        return lives;
    }
};    
\end{lstlisting}


\section{Peeking Iterator (M)}
Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next().\\

Here is an example. Assume that the iterator is initialized to the beginning of the list: [1, 2, 3].\\
Call next() gets you 1, the first element in the list.\\
Now you call peek() and it returns 2, the next element. Calling next() after that still return 2.\\
You call next() the final time and it returns 3, the last element. Calling hasNext() after that should return false.\\

Hint:\\
    Think of "looking ahead". You want to cache the next element.\\
    Is one variable sufficient? Why or why not?\\
    Test your design with call order of peek() before next() vs next() before peek().\\
    For a clean implementation, check out Google's guava library source code. \\

Follow up: How would you extend your design to be generic and work with all types, not just integer?\\

\begin{lstlisting}
// Below is the interface for Iterator, which is already defined for you.
// **DO NOT** modify the interface for Iterator.
class Iterator {
    struct Data;
	Data* data;
public:
	Iterator(const vector<int>& nums);
	Iterator(const Iterator& iter);
	virtual ~Iterator();
	// Returns the next element in the iteration.
	int next();
	// Returns true if the iteration has more elements.
	bool hasNext() const;
};


class PeekingIterator : public Iterator {
public:
	PeekingIterator(const vector<int>& nums) : Iterator(nums) {
	    // Initialize any member here.
	    // **DO NOT** save a copy of nums and manipulate it directly.
	    // You should only use the Iterator interface methods.
	    flag = false; // use flag to indict if next is saved in value
	}

    // Returns the next element in the iteration without advancing the iterator.
	int peek() {
        if (!flag) {
            value = Iterator::next();
            flag = true;
        }
        return value;
	}

	// hasNext() and next() should behave the same as in the Iterator interface.
	// Override them if needed.
	int next() {
	    if (!flag) {
	        return Iterator::next();
	    } else {
    	    flag = false;
	        return value;
	    }
	}

	bool hasNext() const {
	    if (flag || Iterator::hasNext()) return true;
	    else return false;
	}
	
private:
    bool flag;
    int value;
};
\end{lstlisting}


\section{LRU Cache (H)}
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.\\

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\\
set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. \\

\begin{lstlisting}
class LRUCache(object):

    def __init__(self, capacity):
        """
        :type capacity: int
        """
        self.capacity = capacity
        self.cache = {}  # dict for cache key and value mappings
        self.queue = []  # queue of cache keys
        
    def get(self, key):
        """
        :type key: int
        :rtype: int
        """
        # if key is in the cache
        # update its current position to the end of queue
        # the LRU is stored at the beginning of queue
        if key in self.cache:
            self.queue.remove(key)
            self.queue.insert(0, key)
            return self.cache[key]
        else:
            return -1

    def put(self, key, value):
        """
        :type key: int
        :type value: int
        :rtype: None
        """
        if not key or not value: 
            return None
        # remove the current key from the queue, update later
        if key in self.cache:
            self.queue.remove(key)
        # if key is not in cache and the capacity is full
        # pop LRU from queue and delete it from cache
        elif len(self.queue) == self.capacity:
            lru = self.queue.pop()
            del self.cache[lru]
        # update both cache and queue
        self.cache[key] = value
        self.queue.insert(0, key)


# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
\end{lstlisting}

\begin{lstlisting}
class LRUCache{
public:
    LRUCache(int capacity) {
        cap = capacity;
    }
    
    int get(int key) {
        auto it = m.find(key);
        if (it == m.end()) return -1;
        // void splice (iterator position, list& x, iterator i)
        // transfers only the element pointed by i from x into the container, inserting it at position.
        l.splice(l.begin(), l, it->second);
        return it->second->second;
    }
    
    void set(int key, int value) {
        auto it = m.find(key);
        // if the current key and value exist in list, remove it
        if (it != m.end()) l.erase(it->second);
        // insert the new pair to the top of list
        l.push_front(make_pair(key, value)); 
        m[key] = l.begin();
        // if capacity is exceeded, remove the bottom one
        if (m.size() > cap) {
            int k = l.rbegin()->first;
            l.pop_back();
            m.erase(k);
        }
    }
    
private:
    int cap;
    list<pair<int, int> > l;
    unordered_map<int, list<pair<int, int> >::iterator> m;
};
\end{lstlisting}


\section{Design Tic-Tac-Toe (M)}
Design a Tic-tac-toe game that is played between two players on a n x n grid. \\

You may assume the following rules:\\
A move is guaranteed to be valid and is placed on an empty block.\\
Once a winning condition is reached, no more moves is allowed.\\
A player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game.\\

Example:\\
Given n = 3, assume that player 1 is "X" and player 2 is "O" in the board.\\
TicTacToe toe = new TicTacToe(3);\\

toe.move(0, 0, 1); -> Returns 0 (no one wins)\\
|X| | |\\
| | | | // Player 1 makes a move at (0, 0).\\
| | | |\\

toe.move(0, 2, 2); -> Returns 0 (no one wins)\\
|X| |O|\\
| | | | // Player 2 makes a move at (0, 2).\\
| | | |\\

toe.move(2, 2, 1); -> Returns 0 (no one wins)\\
|X| |O|\\
| | | | // Player 1 makes a move at (2, 2).\\
| | |X|\\

toe.move(1, 1, 2); -> Returns 0 (no one wins)\\
|X| |O|\\
| |O| | // Player 2 makes a move at (1, 1).\\
| | |X|\\

toe.move(2, 0, 1); -> Returns 0 (no one wins)\\
|X| |O|\\
| |O| | // Player 1 makes a move at (2, 0).\\
|X| |X|\\

toe.move(1, 0, 2); -> Returns 0 (no one wins)\\
|X| |O|\\
|O|O| | // Player 2 makes a move at (1, 0).\\
|X| |X|\\

toe.move(2, 1, 1); -> Returns 1 (player 1 wins)\\
|X| |O|\\
|O|O| | // Player 1 makes a move at (2, 1).\\
|X|X|X|\\

Follow up:\\
Could you do better than $O(n^2)$ per move() operation?\\

Hint:\\
Could you trade extra space such that move() operation can be done in O(1)? You need two arrays: int rows[n], int cols[n], plus two variables: diagonal, antidiagonal. \\

\begin{lstlisting}
class TicTacToe {
public:
    /** Initialize your data structure here. */
    TicTacToe(int n) {
        board.resize(n, vector<int>(n, 0));   
    }

    int move(int row, int col, int player) {
        board[row][col] = player;
        int i = 0, j = 0, N = board.size();
        // check row
        for (i = 0; i < N; ++i) {
            if (board[i][0] != 0) {
                for (j = 1; j < N; ++j) {
                    if (board[i][j] != board[i][j - 1]) break;
                }
                if (j == N) return board[i][0];
            }
        }
        // check column
        for (j = 0; j < N; ++j) {
            if (board[0][j] != 0) {
                for (i = 1; i < N; ++i) {
                    if (board[i][j] != board[i - 1][j]) break;
                }
                if (i == N) return board[0][j];
            }
        }
        // check diagonal
        if (board[0][0] != 0) {
            for (i = 1; i < N; ++i) {
                if (board[i][i] != board[i - 1][i - 1]) break;
            }
            if (i == N) return board[0][0];
        }
        // check antidiagonal
        if (board[N - 1][0] != 0) {
            for (i = 1; i < N; ++i) {
                if (board[N - i - 1][i] != board[N - i][i - 1]) break;
            }
            if (i == N) return board[N - 1][0];
        }
        return 0;
    }
    
private:
    vector<vector<int>> board;
};
\end{lstlisting}


\section{Design Snake Game (M)}
Design a Snake game that is played on a device with screen size = width x height. Play the game online if you are not familiar with the game. The snake is initially positioned at the top left corner (0,0) with length = 1 unit. You are given a list of food's positions in row-column order. When a snake eats the food, its length and the game's score both increase by 1. Each food appears one by one on the screen. For example, the second food will not appear until the first food was eaten by the snake. When a food does appear on the screen, it is guaranteed that it will not appear on a block occupied by the snake.\\

Example:\\
Given width = 3, height = 2, and food = [[1,2],[0,1]].\\
Snake snake = new Snake(width, height, food);\\

Initially the snake appears at position (0,0) and the food at (1,2).\\
|S| | |\\
| | |F|\\

snake.move("R"); -> Returns 0\\
| |S| |\\
| | |F|\\

snake.move("D"); -> Returns 0\\
| | | |\\
| |S|F|\\

snake.move("R"); -> Returns 1 (Snake eats the first food and right after that, the second food appears at (0,1) )\\
| |F| |\\
| |S|S|\\

snake.move("U"); -> Returns 1\\
| |F|S|\\
| | |S|\\

snake.move("L"); -> Returns 2 (Snake eats the second food)\\
| |S|S|\\
| | |S|\\

snake.move("U"); -> Returns -1 (Game over because snake collides with border)\\

\begin{lstlisting}
class SnakeGame {
public:
    /** Initialize your data structure here.
        @param width - screen width
        @param height - screen height 
        @param food - A list of food positions
        E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0]. */
    SnakeGame(int width, int height, vector<pair<int, int>> food) {
        this->width = width;
        this->height = height;
        this->food = food;
        score = 0;
        pos.push_back({0, 0});
    }
    
    /** Moves the snake.
        @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down 
        @return The game's score after the move. Return -1 if game over. 
        Game over when snake crosses the screen boundary or bites its body. */
    int move(string direction) {
        auto head = pos.front(), tail = pos.back();
        pos.pop_back();
        if (direction == "U") --head.first;
        else if (direction == "L") --head.second;
        else if (direction == "R") ++head.second;
        else if (direction == "D") ++head.first;
        if (count(pos.begin(), pos.end(), head) || head.first < 0 || head.first >= height || head.second < 0 || head.second >= width) {
            return -1;
        }
        pos.insert(pos.begin(), head);
        if (!food.empty() && head == food.front()) {
            food.erase(food.begin());
            pos.push_back(tail);
            ++score;
        }
        return score;
    }

private:
    int width, height, score;
    vector<pair<int, int>> food, pos;
};
\end{lstlisting}


\section{Design Phone Directory (M)}
Design a Phone Directory which supports the following operations:\\
    get: Provide a number which is not assigned to anyone.\\
    check: Check if a number is available or not.\\
    release: Recycle or release a number.\\

Example:\\
// Init a phone directory containing a total of 3 numbers: 0, 1, and 2.\\
PhoneDirectory directory = new PhoneDirectory(3);\\

// It can return any available phone number. Here we assume it returns 0.\\
directory.get();\\

// Assume it returns 1.\\
directory.get();\\

// The number 2 is available, so return true.\\
directory.check(2);\\

// It returns 2, the only number that is left.\\
directory.get();\\

// The number 2 is no longer available, so return false.\\
directory.check(2);\\

// Release number 2 back to the pool.\\
directory.release(2);\\

// Number 2 is available again, return true.\\
directory.check(2);\\

\begin{lstlisting}
class PhoneDirectory {
public:
    /** Initialize your data structure here
        @param maxNumbers - The maximum numbers that can be stored in the phone directory. */
    PhoneDirectory(int maxNumbers) {
        max_num = maxNumbers;
        next = idx = 0;
        recycle.resize(max_num);
        flag.resize(max_num, 1);
    }
    
    /** Provide a number which is not assigned to anyone.
        @return - Return an available number. Return -1 if none is available. */
    int get() {
        if (next == max_num && idx <= 0) return -1;
        if (idx > 0) {
            int t = recycle[--idx];
            flag[t] = 0;
            return t;
        }
        flag[next] = false;
        return next++;
    }
    
    /** Check if a number is available or not. */
    bool check(int number) {
        return number >= 0 && number < max_num && flag[number];
    }
    
    /** Recycle or release a number. */
    void release(int number) {
        if (number >= 0 && number < max_num && !flag[number]) {
            recycle[idx++] = number;
            flag[number] = 1;
        }
    }
private:
    int max_num, next, idx;
    vector<int> recycle, flag;
};
\end{lstlisting}


\section{Design Twitter (M)}
Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods:\\
    postTweet(userId, tweetId): Compose a new tweet.\\
    getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\\
    follow(followerId, followeeId): Follower follows a followee.\\
    unfollow(followerId, followeeId): Follower unfollows a followee.\\

Example:\\
Twitter twitter = new Twitter();\\

// User 1 posts a new tweet (id = 5).\\
twitter.postTweet(1, 5);\\

// User 1's news feed should return a list with 1 tweet id -> [5].\\
twitter.getNewsFeed(1);\\

// User 1 follows user 2.\\
twitter.follow(1, 2);\\

// User 2 posts a new tweet (id = 6).\\
twitter.postTweet(2, 6);\\

// User 1's news feed should return a list with 2 tweet ids -> [6, 5].\\
// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\\
twitter.getNewsFeed(1);\\

// User 1 unfollows user 2.\\
twitter.unfollow(1, 2);\\

// User 1's news feed should return a list with 1 tweet id -> [5],\\
// since user 1 is no longer following user 2.\\
twitter.getNewsFeed(1);\\

\begin{lstlisting}
class Twitter {
public:
    /** Initialize your data structure here. */
    Twitter() {
        cnt = 0;
    }
    
    /** Compose a new tweet. */
    void postTweet(int userId, int tweetId) {
        follow(userId, userId);
        tweets[userId].insert({cnt++, tweetId});
    }
    
    /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */
    vector<int> getNewsFeed(int userId) {
        vector<int> res;
        map<int, int> top10;
        for (auto it = friends[userId].begin(); it != friends[userId].end(); ++it) {
            int t = *it;
            for (auto a = tweets[t].begin(); a != tweets[t].end(); ++a) {
                if (top10.size() > 0 && top10.begin()->first > a->first && top10.size() > 10) break;
                top10.insert({a->first, a->second});
                if (top10.size() > 10) top10.erase(top10.begin());
            }
        }
        for (auto it = top10.rbegin(); it != top10.rend(); ++it) {
            res.push_back(it->second);
        }
        return res;
    }
    
    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */
    void follow(int followerId, int followeeId) {
        friends[followerId].insert(followeeId);
    }
    
    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */
    void unfollow(int followerId, int followeeId) {
        if (followerId != followeeId) {
            friends[followerId].erase(followeeId);
        }
    }
    
private:
    int cnt;
    unordered_map<int, set<int>> friends;
    unordered_map<int, map<int, int>> tweets;
};

/**
 * Your Twitter object will be instantiated and called as such:
 * Twitter obj = new Twitter();
 * obj.postTweet(userId,tweetId);
 * vector<int> param_2 = obj.getNewsFeed(userId);
 * obj.follow(followerId,followeeId);
 * obj.unfollow(followerId,followeeId);
 */
\end{lstlisting}


\section{Insert Delete GetRandom O(1) (H)}
Design a data structure that supports all following operations in average O(1) time.\\
    insert(val): Inserts an item val to the set if not already present.\\
    remove(val): Removes an item val from the set if present.\\
    getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.\\

Example:\\
// Init an empty set.\\
RandomizedSet randomSet = new RandomizedSet();\\

// Inserts 1 to the set. Returns true as 1 was inserted successfully.\\
randomSet.insert(1);\\

// Returns false as 2 does not exist in the set.\\
randomSet.remove(2);\\

// Inserts 2 to the set, returns true. Set now contains [1,2].\\
randomSet.insert(2);\\

// getRandom should return either 1 or 2 randomly.\\
randomSet.getRandom();\\

// Removes 1 from the set, returns true. Set now contains [2].\\
randomSet.remove(1);\\

// 2 was already in the set, so return false.\\
randomSet.insert(2);\\

// Since 1 is the only number in the set, getRandom always return 1.\\
randomSet.getRandom();\\

\begin{lstlisting}
class RandomizedSet(object):

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.nums = []
        self.map = {}  # val: idx

    def insert(self, val):
        """
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        :type val: int
        :rtype: bool
        """
        if val not in self.map:
            self.nums.append(val)  # O(1)
            self.map[val] = len(self.nums) - 1  # O(1)
            return True
        return False
        

    def remove(self, val):
        """
        Removes a value from the set. Returns true if the set contained the specified element.
        :type val: int
        :rtype: bool
        """
        if val in self.map:
            # get the idx of val and the last val in nums
            idx, last = self.map[val], self.nums[-1]
            # overwrite nums[idx] by the last val, 
            # so the last val can be popped from the list with O(1) 
            self.nums[idx] = last
            self.nums.pop()
            # update the map between the original last val and the new idx
            # then delete val from map
            self.map[last] = idx
            del self.map[val]
            return True
        return False

    def getRandom(self):
        """
        Get a random element from the set.
        :rtype: int
        """
        return self.nums[random.randint(0, len(self.nums)-1)]


# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()
\end{lstlisting}

\begin{lstlisting}
class RandomizedSet {
public:
    /** Initialize your data structure here. */
    RandomizedSet() {}
    
    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    bool insert(int val) {
        if (m.count(val)) return false;
        nums.push_back(val);
        m[val] = nums.size()-1; // index is the last index of nums
        return true;
    }
    
    /** Removes a value from the set. Returns true if the set contained the specified element. */
    // switch val and last in nums, then remove the end of nums
    bool remove(int val) {
        if (!m.count(val)) return false;
        int last = nums.back(); // save the last element of nums
        m[last] = m[val]; // update the index of last to the index of val
        nums[m[val]] = last; // overwrite val in nums by last
        nums.pop_back(); // remove the end in nums
        m.erase(val); // remove val in m
        return true;
    }
    
    /** Get a random element from the set. */
    int getRandom() {
        return nums[rand() % nums.size()];
    }
private:
    vector<int> nums;
    unordered_map<int, int> m;
};

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * bool param_1 = obj.insert(val);
 * bool param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
\end{lstlisting}


\section{Insert Delete GetRandom O(1) - Duplicates allowed ? (H)}
Design a data structure that supports all following operations in average O(1) time.\\
Note: Duplicate elements are allowed.\\
    insert(val): Inserts an item val to the collection.\\
    remove(val): Removes an item val from the collection if present.\\
    getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.\\

Example:\\
// Init an empty collection.\\
RandomizedCollection collection = new RandomizedCollection();\\

// Inserts 1 to the collection. Returns true as the collection did not contain 1.\\
collection.insert(1);\\

// Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].\\
collection.insert(1);\\

// Inserts 2 to the collection, returns true. Collection now contains [1,1,2].\\
collection.insert(2);\\

// getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3.\\
collection.getRandom();\\

// Removes 1 from the collection, returns true. Collection now contains [1,2].\\
collection.remove(1);\\

// getRandom should return 1 and 2 both equally likely.\\
collection.getRandom();\\

\begin{lstlisting}
class RandomizedCollection {
public:
    /** Initialize your data structure here. */
    RandomizedCollection() {}
    
    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */
    bool insert(int val) {
        m[val].push_back(nums.size());
        nums.push_back(val);
        return m[val].size() == 1;
    }
    
    /** Removes a value from the collection. Returns true if the collection contained the specified element. */
    bool remove(int val) {
        if (!m.count(val)) return false;
        int last = nums.back(), pos = m[val].back(); 
        m[last].back() = m[val].back();
        if (m[val].size() > 1) m[val].pop_back();
        else m.erase(val);
        nums.pop_back();
        nums[pos] = last;
        return true;
    }
    
    /** Get a random element from the collection. */
    int getRandom() {
        return nums[rand() % nums.size()];
    }
    
private:
    vector<int> nums;
    unordered_map<int, vector<int>> m;
};

/**
 * Your RandomizedCollection object will be instantiated and called as such:
 * RandomizedCollection obj = new RandomizedCollection();
 * bool param_1 = obj.insert(val);
 * bool param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
\end{lstlisting}


\section{Basic Calculator (H)}
Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces . You may assume that the given expression is always valid.\\

Some examples:\\
$"1 + 1" = 2$\\
$" 2-1 + 2 " = 3$\\
$"(1+(4+5+2)-3)+(6+8)" = 23$\\

Note: Do not use the eval built-in library function. \\

\begin{lstlisting}
class Solution {
public:
    int calculate(string s) {
        int res = 0;
        vector<int> sign(2, 1); // use sign to decide add or minus
        for (int i = 0; i < s.size(); ++i) {
            char c = s[i];
            if (c >= '0') {
                int num = 0;
                while (i < s.size() && s[i] >= '0') {
                    num = 10 * num + s[i++] - '0'; // get the value
                }
                res += sign.back() * num;
                sign.pop_back();
                --i;
            }
            else if (c == ')') sign.pop_back();
            else if (c != ' ') sign.push_back(sign.back() * (c == '-' ? -1 : 1));
        }
        return res;
    }
};
\end{lstlisting}


\section{Basic Calculator II (M)}
Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero. You may assume that the given expression is always valid.

Some examples:\\
$"3+2*2" = 7$\\
$" 3/2 " = 1$\\
$" 3+5 / 2 " = 5$\\

Note: Do not use the eval built-in library function. \\

\begin{lstlisting}
class Solution {
public:
    int calculate(string s) {
        int res = 0, d = 0;
        char sign = '+';
        stack<int> nums;
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] >= '0') {
                d = d * 10 + s[i] - '0';
            }
            if ((s[i] < '0' && s[i] != ' ') || i == s.size() - 1) {
                if (sign == '+') nums.push(d);
                if (sign == '-') nums.push(-d);
                if (sign == '*' || sign == '/') {
                    int tmp = sign == '*' ? nums.top() * d : nums.top() / d;
                    nums.pop();
                    nums.push(tmp);
                }
                sign = s[i];
                d = 0;
            } 
        }
        while (!nums.empty()) {
            res += nums.top();
            nums.pop();
        }
        return res;
    }
};
\end{lstlisting}


\section{Expression Add Operators (H)}
Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.\\

Examples:\\
"123", 6 $->$ ["1+2+3", "1*2*3"] \\
"232", 8 $->$ ["2*3+2", "2+3*2"]\\
"105", 5 $->$ ["1*0+5","10-5"]\\
"00", 0 $->$ ["0+0", "0-0", "0*0"]\\
"3456237490", 9191 $->$ []\\

\begin{lstlisting}
class Solution {
public:
    vector<string> addOperators(string num, int target) {
        vector<string> res;
        addOperatorsDFS(num, target, 0, 0, "", res);
        return res;
    }
    void addOperatorsDFS(string num, int target, long long diff, long long curNum, string out, vector<string> &res) {
        if (num.size() == 0 && curNum == target) {
            res.push_back(out);
        }
        for (int i = 1; i <= num.size(); ++i) {
            string cur = num.substr(0, i);
            if (cur.size() > 1 && cur[0] == '0') return;
            string next = num.substr(i);
            if (out.size() > 0) {
                addOperatorsDFS(next, target, stoll(cur), curNum + stoll(cur), out + "+" + cur, res);
                addOperatorsDFS(next, target, -stoll(cur), curNum - stoll(cur), out + "-" + cur, res);
                addOperatorsDFS(next, target, diff * stoll(cur), (curNum - diff) + diff * stoll(cur), out + "*" + cur, res);
            } else {
                addOperatorsDFS(next, target, stoll(cur), stoll(cur), cur, res);
            }
        }
    }
};
\end{lstlisting}


\section{Implement Trie (Prefix Tree) (M)}
Implement a trie with insert, search, and startsWith methods.\\

Note:
You may assume that all inputs are consist of lowercase letters a-z. \\

\begin{lstlisting}
class TrieNode(object):
    
    def __init__(self):
        self.isEnd = False
        self.children = {} # hash between char and TrieNode 
        
        
class Trie(object):

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.root = TrieNode()
        

    def insert(self, word):
        """
        Inserts a word into the trie.
        :type word: str
        :rtype: None
        """
        node = self.root
        # for each char in word, either update node.children or move node to it's TrieNode
        for c in word:
            if not c in node.children:
                node.children[c] = TrieNode()
            node = node.children[c]
        node.isEnd = True
        

    def search(self, word):
        """
        Returns if the word is in the trie.
        :type word: str
        :rtype: bool
        """
        node = self.root
        # check all chars in word by traversaling all node childrens
        for c in word:
            if c in node.children:
                node = node.children[c]
            else:
                return False
        return node.isEnd
        

    def startsWith(self, prefix):
        """
        Returns if there is any word in the trie that starts with the given prefix.
        :type prefix: str
        :rtype: bool
        """
        node = self.root
        # check all chars in prefix by traversaling all node childrens
        for c in prefix:
            if c in node.children:
                node = node.children[c]
            else:
                return False
        return True
        
# Your Trie object will be instantiated and called as such:
# obj = Trie()
# obj.insert(word)
# param_2 = obj.search(word)
# param_3 = obj.startsWith(prefix)
\end{lstlisting}

\begin{lstlisting}
class TrieNode {
public:
    // Initialize your data structure here.
    TrieNode *child[26];
    bool isWord;
    TrieNode() : isWord(false){
        for (auto &a : child) a = NULL;
    }
};

class Trie {
public:
    Trie() {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
    void insert(string s) {
        TrieNode *p = root;
        for (auto &a : s) {
            int i = a - 'a';
            if (!p->child[i]) p->child[i] = new TrieNode();
            p = p->child[i];
        }
        p->isWord = true;
    }

    // Returns if the word is in the trie.
    bool search(string key) {
        TrieNode *p = root;
        for (auto &a : key) {
            int i = a - 'a';
            if (!p->child[i]) return false;
            p = p->child[i];
        }
        return p->isWord;
    }

    // Returns if there is any word in the trie
    // that starts with the given prefix.
    bool startsWith(string prefix) {
        TrieNode *p = root;
        for (auto &a : prefix) {
            int i = a - 'a';
            if (!p->child[i]) return false;
            p = p->child[i];
        }
        return true;
    }

private:
    TrieNode* root;
};

// Your Trie object will be instantiated and called as such:
// Trie trie;
// trie.insert("somestring");
// trie.search("key");
\end{lstlisting}


\section{Add and Search Word - Data structure design (M)}
Design a data structure that supports the following two operations:\\
void addWord(word)\\
bool search(word)\\
search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.\\

For example:\\
addWord("bad")\\
addWord("dad")\\
addWord("mad")\\
search("pad") $->$ false\\
search("bad") $->$ true\\
search(".ad") $->$ true\\
search("b..") $->$ true\\

Note:\\
You may assume that all words are consist of lowercase letters a-z.\\
You should be familiar with how a Trie works. If not, please work on this problem: Implement Trie (Prefix Tree) first. \\

\begin{lstlisting}
class TrieNode(object):
    
    def __init__(self):
        self.isEnd = False
        self.children = {}

class WordDictionary(object):

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.root = TrieNode()
        

    def addWord(self, word):
        """
        Adds a word into the data structure.
        :type word: str
        :rtype: None
        """
        node = self.root
        for c in word:
            if not c in node.children:
                node.children[c] = TrieNode()
            node = node.children[c]
        node.isEnd = True
        

    def search(self, word):
        """
        Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.
        :type word: str
        :rtype: bool
        """
        return self.searchFrom(self.root, word)

    def searchFrom(self, node, word):
        for i in range(len(word)):
            c = word[i]
            # for dot symbol, check if the substring after dot is in Trie
            if c == '.':
                for k in node.children:
                    if self.searchFrom(node.children[k], word[i+1:]):
                        return True
                return False
            elif c not in node.children:
                return False
            node = node.children[c]
        return node.isEnd
        


# Your WordDictionary object will be instantiated and called as such:
# obj = WordDictionary()
# obj.addWord(word)
# param_2 = obj.search(word)
\end{lstlisting}

\begin{lstlisting}
class WordDictionary {
public:
    struct TrieNode {
    public:
        TrieNode *child[26];
        bool isWord;
        TrieNode() : isWord(false) {
            for (auto &a : child) a = NULL;
        }
    };
    
    WordDictionary() {
        root = new TrieNode();
    }
    
    // Adds a word into the data structure.
    void addWord(string word) {
        TrieNode *p = root;
        for (auto &a : word) {
            int i = a - 'a';
            if (!p->child[i]) p->child[i] = new TrieNode();
            p = p->child[i];
        }
        p->isWord = true;
    }

    // Returns if the word is in the data structure. A word could
    // contain the dot character '.' to represent any one letter.
    bool search(string word) {
        return searchWord(word, root, 0);
    }
    
    bool searchWord(string &word, TrieNode *p, int i) {
        if (i == word.size()) return p->isWord;
        if (word[i] == '.') {
            for (auto &a : p->child) {
                if (a && searchWord(word, a, i + 1)) return true;
            }
            return false;
        } else {
            return p->child[word[i] - 'a'] && searchWord(word, p->child[word[i] - 'a'], i + 1);
        }
    }
    
private:
    TrieNode *root;
};

// Your WordDictionary object will be instantiated and called as such:
// WordDictionary wordDictionary;
// wordDictionary.addWord("word");
// wordDictionary.search("pattern");

// Your WordDictionary object will be instantiated and called as such:
// WordDictionary wordDictionary;
// wordDictionary.addWord("word");
// wordDictionary.search("pattern");
\end{lstlisting}

\section{Design HashSet (M)}
Design a HashSet without using any built-in hash table libraries.\\

To be specific, your design should include these functions:\\

    add(value): Insert a value into the HashSet. \\
    contains(value) : Return whether the value exists in the HashSet or not.\\
    remove(value): Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.\\

\begin{lstlisting}
class MyHashSet(object):

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.data = [0 for i in range(1000000)]
        

    def add(self, key):
        """
        :type key: int
        :rtype: None
        """
        self.data[key] = 1

    def remove(self, key):
        """
        :type key: int
        :rtype: None
        """
        self.data[key] = 0

    def contains(self, key):
        """
        Returns true if this set contains the specified element
        :type key: int
        :rtype: bool
        """
        return self.data[key] == 1


# Your MyHashSet object will be instantiated and called as such:
# obj = MyHashSet()
# obj.add(key)
# obj.remove(key)
# param_3 = obj.contains(key)
\end{lstlisting}

\section{Design HashMap (M)}
Design a HashMap without using any built-in hash table libraries.\\

To be specific, your design should include these functions:\\
    put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value.\\
    get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.\\
    remove(key) : Remove the mapping for the value key if this map contains the mapping for the key.\\

\begin{lstlisting}
class MyHashMap(object):

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.data = [-1 for i in range(1000000)]
        
    def put(self, key, value):
        """
        value will always be non-negative.
        :type key: int
        :type value: int
        :rtype: None
        """
        self.data[key] = value
        
    def get(self, key):
        """
        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key
        :type key: int
        :rtype: int
        """
        return self.data[key]
        
    def remove(self, key):
        """
        Removes the mapping of the specified value key if this map contains a mapping for the key
        :type key: int
        :rtype: None
        """
        self.data[key] = -1

# Your MyHashMap object will be instantiated and called as such:
# obj = MyHashMap()
# obj.put(key,value)
# param_2 = obj.get(key)
# obj.remove(key)
\end{lstlisting}

\section{Sparse Vector Dot Product (FB high frequency)}
How to compute sparse vector dot product efficiently?\\
Solution:\\
1. HashMap: O(M*N)\\
2. Binary Search: O(MlogN), N is the longer vector\\
3. Sorting + Two pointers: O(M+N)\\

\section{Reservoir Sampling (FB high frequency)}
Reservoir sampling is a family of randomized algorithms for randomly choosing k samples from a list of n items, where n is either a very large or unknown number. Typically n is large enough that the list doesn’t fit into main memory. For example, a list of search queries in Google and Facebook.

\begin{lstlisting}
# A function to randomly select k items from stream[0..n-1]. 
def selectKItems(stream, n, k): 
        # index for elements in stream[] 
        i=0;  
          
        # reservoir[] is the output array. 
        # Initialize it with first k elements from stream[] 
        reservoir = [0]*k; 
        for i in range(k): 
            reservoir[i] = stream[i]; 
          
        # Iterate from the (k+1)th element to nth element in stream[]
        while(i < n): 
            # Pick a random index from 0 to i. 
            j = random.randrange(i+1); 
              
            # If the randomly picked index is smaller than k, 
            # then replace the element present at the index j with new element from stream i
            # otherwise we keep reservoir[] as the same
            if(j < k): 
                reservoir[j] = stream[i]; 
            # we keep increasing i until all n items in stream[] are checked
            i+=1; 
\end{lstlisting}
