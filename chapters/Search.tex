\chapter{Search}

\section{Binary Search}


\subsection{First Bad Version (E)}
You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. \\

\begin{lstlisting}
// Forward declaration of isBadVersion API.
bool isBadVersion(int version);

class Solution {
public:
    int firstBadVersion(int n) {
        int start = 1, end = n, mid;
        while (start < end) {
            mid = start + (end - start) / 2;
            if (!isBadVersion(mid))
                start = mid + 1;
            else
                end = mid;          // the current mid could be the first bad version
        }
        return start;
    }
};
\end{lstlisting}


\subsection{Search Insert Position (M)}
Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. 
You may assume no duplicates in the array.\\

Here are few examples.\\
$[1,3,5,6], 5 -> 2$\\
$[1,3,5,6], 2 -> 1$\\
$[1,3,5,6], 7 -> 4$\\
$[1,3,5,6], 0 -> 0$\\

\begin{lstlisting}
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (target < nums[mid]) {
                right = mid - 1;
            } else if (target > nums[mid]) {
                left = mid + 1;
            } else {
                return mid;
            }
        }
        return left;
    }
};
\end{lstlisting}


\subsection{Find Peak Element (M)}
A peak element is an element that is greater than its neighbors.\\

Given an input array where num[i] $\neq$ num[i+1], find a peak element and return its index.
The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
You may imagine that num[-1] = num[n] = $-\infty$.\\

For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.\\

\begin{lstlisting}
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int start = 0, end = nums.size()-1;
        while (start < end) {
            int mid = start + (end - start) / 2;
            if (nums[mid] > nums[mid+1]) {
                end = mid;
            } else if (nums[mid] < nums[mid+1]) {
                start = mid + 1;
            }
        }
        return start;
    }
};
\end{lstlisting}


\subsection{Search a 2D Matrix (M)}
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\\
    Integers in each row are sorted from left to right.\\
    The first integer of each row is greater than the last integer of the previous row.\\

For example,
Consider the following matrix:
[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]\\
Given target = 3, return true.\\

\begin{lstlisting}
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        int left = 0, right = m * n - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            int val = matrix[mid/n][mid%n];// convert 1D index to 2D index
            if (target == val)
                return true;
            else if (target > val)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return false;
    }
};
\end{lstlisting}


\subsection{Search a 2D Matrix II (M)}
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\\
    Integers in each row are sorted in ascending from left to right.\\
    Integers in each column are sorted in ascending from top to bottom.\\

For example,
Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]\\
Given target = 5, return true. Given target = 20, return false.\\

\begin{lstlisting}
// 1. Binary search for each row: O(MlogN)
class Solution {
public:
    bool searchMatrix(vector<vector<int>> &matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        bool res = false;
        for (int i = 0; i < m; ++i) {
            if (matrix[i][0] <= target && target <= matrix[i][n-1]) {
                res = binarySearch(matrix, target, i, n);
                if (res == true) break;
            }
        }
        return res;
    }
    bool binarySearch(vector<vector<int>> &matrix, int target, int row, int length) {
        int left = 0, right = length-1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (target == matrix[row][mid]) {
                return true;
            } else if (target > matrix[row][mid]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return false;
    }
};

// 2. O(M+N) solution
// Starting from a corner of matrix, 
// if one direction is ascending and another is decending,
// then this method works!
// e.g. for this case, starting from the bottom left corner or upper right corner
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        int i = 0, j = n - 1;
        // starting from the upper right corner
        while(i < m && j >= 0) {
            if (target == matrix[i][j])
                return true;
            else if (target < matrix[i][j])
                --j;
            else
                ++i;
        }
        return false;
    }
};
\end{lstlisting}


\subsection{Kth Smallest Element in a Sorted Matrix (M)}
Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.\

Note that it is the kth smallest element in the sorted order, not the kth distinct element.\\

Example:\\
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],\\
k = 8, return 13.\\

Note:
You may assume k is always valid, $1 \leq k \leq n^2$.\\

\begin{lstlisting}
// 1. Binary search
class Solution {
public:
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        int left = matrix[0][0], right = matrix.back().back();
        while (left < right) {
            int mid = left + (right - left) / 2, cnt = 0;
            // upper_bound(): Returns an iterator pointing to the first element 
            // in the range [first,last) which compares greater than val.
            for (int i = 0; i < matrix.size(); ++i) {
                // get the position of upper_bound compared to mid
                cnt += upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();
            }
            if (cnt < k) left = mid + 1;
            else right = mid;
        }
        return left;
    }
};

// 2. Heap
class Solution {
public:
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        priority_queue<int, vector<int>> q;
        for (int i = 0; i < matrix.size(); ++i) {
            for (int j = 0; j < matrix[i].size(); ++j) {
                q.emplace(matrix[i][j]);
                if (q.size() > k) q.pop();
            }
        }
        return q.top();
    }
};
\end{lstlisting}


\subsection{Guess Number Higher or Lower (E)}
We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number is higher or lower.\\

You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):\\
-1 : My number is lower\\ 
 1 : My number is higher\\
 0 : Congrats! You got it!\\

Example:\\
n = 10, I pick 6.\\
Return 6.\\

\begin{lstlisting}
// Forward declaration of guess API.
// @param num, your guess
// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
int guess(int num);

class Solution {
public:
    int guessNumber(int n) {
        int start = 1, end = n;
        
        while (start <= end) {
            int mid = start + (end - start) / 2;
            int res = guess(mid);
            
            if (res == 0)   
                return mid;
            else if (res == 1)  
                start = mid + 1;
            else
                end = mid - 1;
        }
        
        return start;
    }
};
\end{lstlisting}


\subsection{Guess Number Higher or Lower II (M)}
We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number I picked is higher or lower. However, when you guess a particular number x, and you guess wrong, you pay \$x. You win the game when you guess the number I picked. \\

Example:\\
n = 10, I pick 8.\\
First round:  You guess 5, I tell you that it's higher. You pay \$5. \\
Second round: You guess 7, I tell you that it's higher. You pay \$7.\\
Third round:  You guess 9, I tell you that it's lower. You pay \$9.\\
Game over. 8 is the number I picked.\\
You end up paying \$5 + \$7 + \$9 = \$21.\\

Given a particular n $\geq$ 1, find out how much money you need to have to guarantee a win.\\

\begin{lstlisting}
class Solution {
public:
    int getMoneyAmount(int n) {
        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));
        return solver(dp, 1, n);
    }
    
    int solver(vector<vector<int>> &dp, int L, int R) {
        if (L >= R) return 0;
        if (dp[L][R]) return dp[L][R];
        
        dp[L][R] = INT_MAX;
        
        // f(x) = x + max(solver(L,x-1),solver(x+1,n))
        // get the minimum f(x) for x = 1~n
        for (int i = L; i <= R; ++i) {
            dp[L][R] = min(dp[L][R], i + max(solver(dp, L, i-1), solver(dp, i+1, R)));
        }
        
        return dp[L][R];
    }
};
\end{lstlisting}


\subsection{Find Minimum in Rotated Sorted Array (M)}
Suppose a sorted array is rotated at some pivot unknown to you beforehand.
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
Find the minimum element.
You may assume no duplicate exists in the array.\\

\begin{lstlisting}
class Solution {
public:
    int findMin(vector<int> &nums) {
        int left = 0, right = nums.size()-1;
        // If nums[left] > nums[right], then the array/subarray must be rotated 
        // Otherwise, the array/subarray is not rotated and nums[left] is the minimum
        while (left < right && nums[left] > nums[right]) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[right]) { //min must exist in right part
                left = mid + 1;
            } else { //otherwise min is in the left part
                right = mid;
            }
        }
        return nums[left];
    }
};
\end{lstlisting}


\subsection{Find Minimum in Rotated Sorted Array II (H)}
Suppose a sorted array is rotated at some pivot unknown to you beforehand.
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
Find the minimum element.
The array may contain duplicates.\\

\begin{lstlisting}
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size()-1;
        while (left < right && nums[left] >= nums[right]) { //consider deplicates
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[right])
                left = mid + 1;
            else if (nums[mid] < nums[right])
                right = mid;
            else //if duplicates exist, skip the leftmost element and procees to the next
                left = left + 1;
        }
        return nums[left];
    }
};
\end{lstlisting}


\subsection{Search in Rotated Sorted Array (H)}
Suppose a sorted array is rotated at some pivot unknown to you beforehand.
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
You are given a target value to search. If found in the array return its index, otherwise return -1.
You may assume no duplicate exists in the array.\\

\begin{lstlisting}
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size()-1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < nums[right]) { //right part is sorted
                if (nums[mid] < target && target <= nums[right]) { //target exists in the right part
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }            
            } else { //left part is sorted
                if (nums[left] <= target && target < nums[mid]) { //target exists in the left part
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
        }
        return -1;
    }
};
\end{lstlisting}


\subsection{Search in Rotated Sorted Array II (M)}
Follow up for "Search in Rotated Sorted Array":
What if duplicates are allowed?
Would this affect the run-time complexity? How and why?
Write a function to determine if a given target is in the array.\\

\begin{lstlisting}
class Solution {
public:
    bool search(vector<int> &nums, int target) {
        int left = 0, right = nums.size()-1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return true;
            } else if (nums[mid] < nums[right]) {
                if (nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            } else if (nums[mid] > nums[right]) {
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else { //skip duplicates by leftshift the right index
                --right;
            }
        }
        return false;
    }
};
\end{lstlisting}


\section{Deep-first Search}
\subsection{Walls and Gates (M)}
You are given a m x n 2D grid initialized with these three possible values.\\
    -1 - A wall or an obstacle.\\
    0 - A gate.\\
    INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.\\

Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.\\

For example, given the 2D grid:\\
INF  -1  0  INF\\
INF INF INF  -1\\
INF  -1 INF  -1\\
  0  -1 INF INF\\

After running your function, the 2D grid should be:\\
  3  -1   0   1\\
  2   2   1  -1\\
  1  -1   2  -1\\
  0  -1   3   4\\

\begin{lstlisting}
class Solution {
public:
    void wallsAndGates(vector<vector<int>>& rooms) {
        for (int i = 0; i < rooms.size(); ++i) {
            for (int j = 0; j < rooms[i].size(); ++j) {
                if (rooms[i][j] == 0) {
                    dfs(rooms, i, j, 0);
                }
            }
        }
    }
    void dfs(vector<vector<int>> &rooms, int i, int j, int val) {
        if (i < 0 || i >= rooms.size() || j < 0 || j >= rooms[i].size() || rooms[i][j] < val) return;
        rooms[i][j] = val;
        dfs(rooms, i + 1, j, val + 1);
        dfs(rooms, i - 1, j, val + 1);
        dfs(rooms, i, j + 1, val + 1);
        dfs(rooms, i, j - 1, val + 1);
    }
};
\end{lstlisting}


\subsection{Subset (M)}
Given a set of distinct integers, nums, return all possible subsets.\\
Note: The solution set must not contain duplicate subsets.\\
For example,
If nums = [1,2,3], a solution is:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]\\

\begin{lstlisting}
// 1. Recursive
class Solution {
public:
    vector<vector<int>> subsets(vector<int> &nums) {
        vector<vector<int>> res;
        vector<int> out;
        sort(nums.begin(), nums.end());
        getSubsets(nums, res, out, 0);
        return res;
    }
    void getSubsets(vector<int> &nums, vector<vector<int>> &res, vector<int> &out, int pos) {
        res.push_back(out);
        for (int i = pos; i < nums.size(); ++i) {
            out.push_back(nums[i]);
            getSubsets(nums, res, out, i+1);
            out.pop_back();
        }
    }
};

// 2. Iterative
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res(1, vector<int>());
        for (int i = 0; i < nums.size(); ++i) {
            int n = res.size();
            for (int j = 0; j < n; ++j) {
                res.push_back(res[j]);
                res.back().push_back(nums[i]);
            }
        }
        return res;
    }
};
\end{lstlisting}


\subsection{Subset II (M)}
Given a collection of integers that might contain duplicates, nums, return all possible subsets.\\
Note: The solution set must not contain duplicate subsets.\\
For example,
If nums = [1,2,2], a solution is:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]\\

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        vector<int> out;
        getSubsets(nums, res, out, 0);
        return res;
    }
    void getSubsets(vector<int>& nums, vector<vector<int>>& res, vector<int>& out, int pos) {
        res.push_back(out);
        for (int i = pos; i < nums.size(); ++i) {
            if (i == pos || nums[i] != nums[i-1]) {
                out.push_back(nums[i]);
                getSubsets(nums, res, out, i+1);
                out.pop_back();
            }
        }
    }
};
\end{lstlisting}


\subsection{Permutations (M)}
Given a collection of distinct numbers, return all possible permutations. \\

For example,
[1,2,3] have the following permutations: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]\\

\begin{lstlisting}
// 1. Use visited vector
class Solution {
public:
    vector<vector<int> > permute(vector<int> &num) {
        vector<vector<int>> res;
        vector<int> out;
        vector<int> visited(num.size(), 0); // save visited states
        permuteDFS(num, 0, visited, out, res);
        return res;
    }
    void permuteDFS(vector<int> &num, int level, vector<int> &visited, vector<int> &out, vector<vector<int>> &res) {
        if (level == num.size()) res.push_back(out);
        else {
            for (int i = 0; i < num.size(); ++i) {
                if (visited[i] == 0) {
                    visited[i] = 1;
                    out.push_back(num[i]);
                    permuteDFS(num, level + 1, visited, out, res);
                    out.pop_back();
                    visited[i] = 0;
                }
            }
        }
    }
};

// 2. Use swap function
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
        permuteDFS(nums, 0, nums.size()-1, res);
        return res;
    }
    void permuteDFS(vector<int>& nums, int start, int end, vector<vector<int>> &res) {
        if (start > end) {
            res.push_back(nums);
            return;
        }
        for (int i = start; i <= end; ++i) {
            swap(nums[start], nums[i]);
            permuteDFS(nums, start+1, end, res);
            swap(nums[start], nums[i]);
        }
    }
};
\end{lstlisting}


\subsection{Permutations II (M)}
Given a collection of numbers that might contain duplicates, return all possible unique permutations.\\

For example, [1,1,2] have the following unique permutations:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
] \\

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int> &num) {
        vector<vector<int>> res;
        vector<int> out;
        vector<int> visited(num.size(), 0);
        sort(num.begin(), num.end());
        permuteUniqueDFS(num, 0, visited, out, res);
        return res;
    }
    void permuteUniqueDFS(vector<int> &num, int level, vector<int> &visited, vector<int> &out, vector<vector<int>> &res) {
        if (level >= num.size()) res.push_back(out);
        else {
            for (int i = 0; i < num.size(); ++i) {
                if (visited[i] == 0) {
                    // skip duplicates
                    if (i > 0 && num[i] == num[i-1] && visited[i-1] == 0) continue;
                    visited[i] = 1;
                    out.push_back(num[i]);
                    permuteUniqueDFS(num, level + 1, visited, out, res);
                    out.pop_back();
                    visited[i] = 0;
                }
            }
        }
    }
};

class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        permuteUniqueDFS(nums, 0, nums.size()-1, res);
        return res;
    }
    // Do not use reference of nums and do not swap back after recursion
    void permuteUniqueDFS(vector<int> nums, int start, int end, vector<vector<int>> &res) {
        if (start > end) {
            res.push_back(nums);
            return;
        }
        for (int i = start; i <= end; ++i) {
            if (i != start && nums[start] == nums[i]) continue;
            swap(nums[start], nums[i]);
            permuteUniqueDFS(nums, start+1, end, res);
        }
    }
};
\end{lstlisting}


\subsection{Next Permutation (M)}
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory.\\

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\\
1,2,3 $->$ 1,3,2\\
3,2,1 $->$ 1,2,3\\
1,1,5 $->$ 1,5,1\\

\begin{lstlisting}
// 1. Find the first num that is smaller than 7:
//      1   2#  7   4   3   1
// 2. Find the first num that is larger than 2:
//      1   2   7   4   3#  1
// 3. Swap 2 and 3:
//      1   3#  7   4   2#  1
// 4. Reverse the left numbers after 3: 
//      1   3   1#  2#  4#  7#
class Solution {
public:
    void nextPermutation(vector<int> &num) {
        int i, j, n = num.size();
        for (i = n - 2; i >= 0; --i) {
            if (num[i + 1] > num[i]) { // step 1
                for (j = n - 1; j >= i; --j) {
                    if (num[j] > num[i]) break; // step 2
                }
                swap(num[i], num[j]); // step 3
                reverse(num.begin() + i + 1, num.end()); // step 4
                return;
            }
        }
        reverse(num.begin(), num.end()); // reverse nums if no next permutation
    }
};
\end{lstlisting}


\subsection{Permutation Sequence (M)}
The set [1,2,3,...,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, We get the following sequence (i.e., for n = 3):
    "123"\\
    "132"\\
    "213"\\
    "231"\\
    "312"\\
    "321"\\
Given n and k, return the kth permutation sequence.\\
Note: Given n will be between 1 and 9 inclusive.\\

\begin{lstlisting}
class Solution {
public:
    string getPermutation(int n, int k) {
        string res;
        string num = "123456789";
        vector<int> f(n, 1);
        for (int i = 1; i < n; ++i) {
            f[i] = f[i - 1] * i; // compute 1!, 2!, ...
        }
        --k; // align index
        for (int i = n; i >= 1; --i) {
            int j = k / f[i - 1];
            k %= f[i - 1];
            res.push_back(num[j]);
            num.erase(j, 1);
        }
        return res;
    }
};
\end{lstlisting}


\subsection{Combinations (M)}
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.\\

For example, If n = 4 and k = 2, a solution is: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4]]\\

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> res;
        vector<int> out;
        if (k > n) return res;
        combineDFS(res, out, 1, n, k);
        return res;
    }
    void combineDFS(vector<vector<int>> &res, vector<int> &out, int start, int end, int k) {
        if (k == 0) res.push_back(out);
        for (int i = start; i <= end; ++i) {
            out.push_back(i);
            combineDFS(res, out, i+1, end, k-1);
            out.pop_back();
        }
    }
};
\end{lstlisting}


\subsection{Combination Sum (M)}
Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times.\\

Note:\\
    All numbers (including target) will be positive integers.\\
    The solution set must not contain duplicate combinations.\\

For example, given candidate set [2, 3, 6, 7] and target 7, A solution set is: [ [7], [2, 2, 3] ]\\

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> res;
        vector<int> out;
        sort(candidates.begin(), candidates.end());
        combinationSumDFS(candidates, target, out, res, 0);
        return res;
    }
    void combinationSumDFS(vector<int>& candidates, int target, vector<int>& out, vector<vector<int>> &res, int index) {
        if (target < 0) {
            return;
        } else if (target == 0) {
            res.push_back(out);
        } else {
            for (int i = index; i < candidates.size(); ++i) {
                out.push_back(candidates[i]);
                combinationSumDFS(candidates, target-candidates[i], out, res, i);
                out.pop_back();
            }
        }
    }
};
\end{lstlisting}


\subsection{Combination Sum II (M)}
Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination.\\

Note:\\
    All numbers (including target) will be positive integers.\\
    The solution set must not contain duplicate combinations.\\

For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] \\

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<vector<int>> res;
        vector<int> out;
        sort(candidates.begin(), candidates.end());
        combinationSum2DFS(candidates, target, out, res, 0);
        return res;        
    }
    void combinationSum2DFS(vector<int>& candidates, int target, vector<int>& out, vector<vector<int>> &res, int index) {
        if (target < 0) {
            return;
        } else if (target == 0) {
            res.push_back(out);
        } else {
            for (int i = index; i < candidates.size(); ++i) {
                if (i == index || candidates[i] != candidates[i-1]) { //skip duplicates
                    out.push_back(candidates[i]);
                    combinationSum2DFS(candidates, target-candidates[i], out, res, i+1);//update i to i+1
                    out.pop_back();
                }
            } 
        }
    }
};
\end{lstlisting}


\subsection{Combination Sum III (M)}
Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. \\

Example 1:\\
Input: k = 3, n = 7\\
Output: [[1,2,4]]\\

Example 2:\\
Input: k = 3, n = 9\\
Output:[[1,2,6], [1,3,5], [2,3,4]]\\

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> res;
        vector<int> out;
        combinationSum3DFS(k, n, out, res, 1);
        return res;
    }
    void combinationSum3DFS(int k, int n, vector<int>& out, vector<vector<int>> &res, int index) {
        if (n < 0) {
            return;
        } else if (k == 0 && n == 0) {
            res.push_back(out);
        } else {
            for (int i = index; i <= 9; ++i) {
                out.push_back(i);
                combinationSum3DFS(k-1, n-i, out, res, i+1);
                out.pop_back();
            }
        }
    }
};
\end{lstlisting}


\subsection{Factor Combinations (M)}
Numbers can be regarded as product of its factors. For example, 8 = 2 x 2 x 2 = 2 x 4.\\

Write a function that takes an integer n and return all possible combinations of its factors.\\

Note: \\
    Each combination's factors must be sorted ascending, for example: The factors of 2 and 6 is [2, 6], not [6, 2].\\
    You may assume that n is always positive.\\
    Factors should be greater than 1 and less than n.\\

Examples: \\
input: 1
output: 
[]\\

input: 37
output: 
[]\\

input: 12
output:
[
  [2, 6],
  [2, 2, 3],
  [3, 4]
]\\

input: 32
output:
[
  [2, 16],
  [2, 2, 8],
  [2, 2, 2, 4],
  [2, 2, 2, 2, 2],
  [2, 4, 4],
  [4, 8]
]\\

\begin{lstlisting}
class Solution {
public:
    vector<vector<int>> getFactors(int n) {
        vector<vector<int>> res;
        dfs(n, 2, {}, res);
        return res;
    }
    void dfs(int n, int start, vector<int> out, vector<vector<int>> &res) {
        if (n == 1) {
            if (out.size() > 1) res.push_back(out);
        } else {
            for (int i = start; i <= n; ++i) {
                if (n % i == 0) {
                    out.push_back(i);
                    dfs(n / i, i, out, res);
                    out.pop_back();
                }
            }
        }
    }
};
\end{lstlisting}


\section{Breadth-first Search}
