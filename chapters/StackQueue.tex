\chapter{Stack and Queue}


\section{Implement Stack using Queues (E)}
Implement the following operations of a stack using queues.\\

    push(x) -- Push element x onto stack.\\
    pop() -- Removes the element on top of the stack.\\
    top() -- Get the top element.\\
    empty() -- Return whether the stack is empty.\\

\begin{lstlisting}
class MyStack(object):

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.queue = []

    def push(self, x):
        """
        Push element x onto stack.
        :type x: int
        :rtype: None
        """
        self.queue.insert(0, x)
        n = len(self.queue)
        for i in range(1, n):
            self.queue.insert(0, self.queue[-1])
            self.queue.pop()
        

    def pop(self):
        """
        Removes the element on top of the stack and returns that element.
        :rtype: int
        """
        return self.queue.pop()
        

    def top(self):
        """
        Get the top element.
        :rtype: int
        """
        return self.queue[-1]
        

    def empty(self):
        """
        Returns whether the stack is empty.
        :rtype: bool
        """
        return not self.queue
        

# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()
\end{lstlisting}

\begin{lstlisting}
class Stack {
queue<int> que;
public:
    // Push element x onto stack.
    void push(int x) {
       que.push(x);                             // push x to tail
       for (int i = 1; i < que.size(); ++i) {   // repeat until x is the head
           que.push(que.front());               // push head to tail
           que.pop();                           // pop the old head
       }
    }

    // Removes the element on top of the stack.
    void pop() {
        que.pop();
    }

    // Get the top element.
    int top() {
        return que.front();
    }

    // Return whether the stack is empty.
    bool empty() {
        return que.empty();
    }
};
\end{lstlisting}


\section{Implement Queue using Stacks (E)}
 Implement the following operations of a queue using stacks.\\

    push(x) -- Push element x to the back of queue.\\
    pop() -- Removes the element from in front of queue.\\
    peek() -- Get the front element.\\
    empty() -- Return whether the queue is empty.\\
  
 \begin{lstlisting}  
 class MyQueue(object):

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.s1 = []
        self.s2 = []
        

    def push(self, x):
        """
        Push element x to the back of queue.
        :type x: int
        :rtype: None
        """
        while self.s1:
            self.s2.append(self.s1.pop())
        self.s1.append(x)
        while self.s2:
            self.s1.append(self.s2.pop())
        

    def pop(self):
        """
        Removes the element from in front of queue and returns that element.
        :rtype: int
        """
        return self.s1.pop()
        

    def peek(self):
        """
        Get the front element.
        :rtype: int
        """
        return self.s1[-1]
        

    def empty(self):
        """
        Returns whether the queue is empty.
        :rtype: bool
        """
        return not self.s1

# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()   
\end{lstlisting}

\begin{lstlisting}
class Queue {
stack<int> s1, s2;
public:
    // Push element x to the back of queue.
    void push(int x) {
        while (!s2.empty()){
            s1.push(s2.top());
            s2.pop();
        }
        s1.push(x);
    }

    // Removes the element from in front of queue.
    void pop(void) {
        while (!s1.empty()) {
            s2.push(s1.top());
            s1.pop();
        }
        s2.pop();
    }

    // Get the front element.
    int peek(void) {
        while (!s1.empty()) {
            s2.push(s1.top());
            s1.pop();
        }
        return s2.top();
    }

    // Return whether the queue is empty.
    bool empty(void) {
        return s1.empty() && s2.empty();
    }
};
\end{lstlisting}


\section{Min Stack (E)}
 Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\\

    push(x) -- Push element x onto stack.\\
    pop() -- Removes the element on top of the stack.\\
    top() -- Get the top element.\\
    getMin() -- Retrieve the minimum element in the stack.\\
    
Example:\\
MinStack minStack = new MinStack();\\
minStack.push(-2);\\
minStack.push(0);\\
minStack.push(-3);\\
minStack.getMin();   $->$ Returns -3.\\
minStack.pop();\\
minStack.top();      $->$ Returns 0.\\
minStack.getMin();   $->$ Returns -2.\\

\begin{lstlisting}
class MinStack {
public:
    stack<int> s;
    stack<int> s_min;                       // use a new stack to store minimum numbers
    
    void push(int x) {
        s.push(x);
        if (s_min.empty() || x <= getMin()) // make a copy of a min value to s_min
            s_min.push(x);
    }
    
    void pop() {
        if (s.top() == getMin())            // update s_min if the min value is poped
            s_min.pop();
        s.pop();
    }
    
    int top() {
        return s.top();
    }
    
    int getMin() {
        return s_min.top();
    }
};
\end{lstlisting}


\section{Moving Average from Data Stream (E)}
Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.\\

For example,\\
MovingAverage m = new MovingAverage(3);\\
m.next(1) = 1\\
m.next(10) = (1 + 10) / 2\\
m.next(3) = (1 + 10 + 3) / 3\\
m.next(5) = (10 + 3 + 5) / 3 \\

\begin{lstlisting}
class MovingAverage {
public:
    MovingAverage(int size) {
        this->size = size;
        sum = 0;
    }
    
    double next(int val) {
        if (q.size() >= size) {	
            sum -= q.front();
            q.pop();
        }
        q.push(val);
        sum += val;
        return sum / q.size();
    }
    
private:
    queue<int> q;
    int size;
    double sum;
};
\end{lstlisting}


\section{Evaluate Reverse Polish Notation (M)}
Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression.\\

Some examples:\\
  $["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9$ \\
  $["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6$ \\

\begin{lstlisting}
// atoi: string to integer
// c_str(): Returns a pointer to a null-terminated character array with data equivalent to those stored in the string
class Solution {
public:
    int evalRPN(vector<string> &tokens) {
        if (tokens.size() == 1) return atoi(tokens[0].c_str());
        stack<int> s;
        for (int i = 0; i < tokens.size(); ++i) {
            if (tokens[i] != "+" && tokens[i] != "-" && tokens[i] != "*" && tokens[i] != "/") {
                s.push(atoi(tokens[i].c_str()));
            } else {
                int m = s.top();
                s.pop();
                int n = s.top();
                s.pop();
                if (tokens[i] == "+") s.push(n + m);
                if (tokens[i] == "-") s.push(n - m);
                if (tokens[i] == "*") s.push(n * m);
                if (tokens[i] == "/") s.push(n / m);
            }
        }
        return s.top();
    }
};
\end{lstlisting}

\section{Remove K Digits (M)}
Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.\\

Note:\\

    The length of num is less than 10002 and will be $>=$ k.\\
    The given num does not contain any leading zero.\\

Example 1:\\
Input: num = "1432219", k = 3\\
Output: "1219"\\
Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\\

Example 2:\\
Input: num = "10200", k = 1\\
Output: "200"\\
Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\\

Example 3:\\
Input: num = "10", k = 2\\
Output: "0"\\
Explanation: Remove all the digits from the number and it is left with nothing which is 0.\\

\begin{lstlisting}
class Solution(object):
    def removeKdigits(self, num, k):
        """
        :type num: str
        :type k: int
        :rtype: str
        """
        res = []
        # only leave the small digits in res
        for n in num:
            while k > 0 and res and res[-1] > n:
                res.pop()
                k -= 1
            res.append(n)
        # make sure exact k digits are removed
        while k > 0 and res:
            res.pop()
            k -= 1
        # remove leading 0s
        while res and res[0] == '0':
            res.pop(0)
        # join list to resume str
        if res:
            return ''.join(res)
        else:
            return '0'
\end{lstlisting}

