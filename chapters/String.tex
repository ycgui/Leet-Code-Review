\chapter{String}


\section{Add Binary (E)}
Given two binary strings, return their sum (also a binary string). \\

For example, a = ``11", b = ``1", Return ``100". \\ 

\begin{lstlisting}
class Solution(object):
    def addBinary(self, a, b):
        """
        :type a: str
        :type b: str
        :rtype: str
        """
        s1, s2 = [], []
        res = ''
        carry = 0
        for i in a:
            s1.append(int(i))
        for i in b:
            s2.append(int(i))
        while s1 or s2:
            val = carry
            if s1:
                val += s1.pop()
            if s2:
                val += s2.pop()
            carry = val / 2
            val %= 2
            res += str(val)         
        if carry == 1:
            res += str(carry)
        return res[::-1]
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    string addBinary(string a, string b) {
        string res = "";
        int ai, bi, val, carry = 0;
        int i = a.size() - 1;
        int j = b.size() - 1;
        
        while (i >= 0 || j >= 0 || carry == 1) {
            if (i >= 0)
                ai = a[i--] - '0';              // convert char to integer
            else
                ai = 0;
                
            if (j >= 0)
                bi = b[j--] - '0';
            else
                bi = 0;
                
            val = (ai + bi + carry) % 2;
            carry = (ai + bi + carry) / 2;
            
            res = char(val + '0') + res;        // convert integer to char by char(val + '0') 
            
        }
        
        return res;
    }
};
\end{lstlisting}

\section{Add Strings (E)}
Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.\\

Note:\\
    The length of both num1 and num2 is < 5100.\\
    Both num1 and num2 contains only digits 0-9.\\
    Both num1 and num2 does not contain any leading zero.\\
    You must not use any built-in BigInteger library or convert the inputs to integer directly.\\
\begin{lstlisting}
class Solution(object):
    def addStrings(self, num1, num2):
        """
        :type num1: str
        :type num2: str
        :rtype: str
        """
        res = ''
        carry = 0
        n1, n2 = len(num1) - 1, len(num2) - 1
        while n1 >= 0 or n2 >= 0:
            val = carry
            if n1 >= 0: 
                val += ord(num1[n1]) - ord('0')
                n1 -= 1
            if n2 >= 0: 
                val += ord(num2[n2]) - ord('0')
                n2 -= 1
            carry = val / 10
            val %= 10
            res = str(val) + res
        if carry > 0:
            res = str(carry) + res
        return res
\end{lstlisting}

\section{Multiply Strings (M)}
Given two numbers represented as strings, return multiplication of the numbers as a string.\\

Note:\\
    The numbers can be arbitrarily large and are non-negative.\\
    Converting the input string to integer is NOT allowed.\\
    You should NOT use internal library such as BigInteger.\\

\begin{lstlisting}
class Solution(object):
    def multiply(self, num1, num2):
        """
        :type num1: str
        :type num2: str
        :rtype: str
        """
        res = ''
        m, n = len(num1), len(num2)
        # the length of res is smaller or equal to m + n
        vals = [0 for i in range(m + n)]
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                mul = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))
                p1 = i + j  # higher bit
                p2 = i + j + 1  #lower bit
                cur_sum = mul + vals[p2]  # add existed lower bit
                vals[p1] += cur_sum / 10  # update higher bit
                vals[p2] = cur_sum % 10   # update lower bit
        # skip leading zeros
        for val in vals:
            if res or val != 0: res += str(val)
        # res could be zero
        if not res:
            return '0'
        else: 
            return res
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    string multiply(string num1, string num2) {
        string res;
        int n1 = num1.size(), n2 = num2.size();
        int k = n1 + n2 - 2, carry = 0;
        vector<int> v(n1 + n2, 0);
        for (int i = 0; i < n1; ++i) {
            for (int j = 0; j < n2; ++j) {
                v[k - i - j] += (num1[i] - '0') * (num2[j] - '0');
            }
        }
        for (int i = 0; i < n1 + n2; ++i) {
            v[i] += carry;
            carry = v[i] / 10;
            v[i] %= 10;
        }
        int i = n1 + n2 - 1;
        while (v[i] == 0) --i;
        if (i < 0) return "0";
        while (i >= 0) res.push_back(v[i--] + '0');
        return res;
    }
};
\end{lstlisting}


\section{Count and Say (E)}
The count-and-say sequence is the sequence of integers beginning as follows: 1, 11, 21, 1211, 111221, ...\\
1 is read off as "one 1" or 11.\\
11 is read off as "two 1s" or 21.\\
21 is read off as "one 2, then one 1" or 1211.\\

Given an integer n, generate the nth sequence. The sequence of integers will be represented as a string. \\

\begin{lstlisting}
class Solution(object):
    def countAndSay(self, n):
        """
        :type n: int
        :rtype: str
        """
        if n <= 0: return ''
        res = '1'
        while n - 1:
            s = ''
            m = len(res)
            j = 0
            while j < m:
                cnt = 1
                # count the same element 
                while j + 1 < m and res[j] == res[j+1]:
                    cnt += 1
                    j += 1
                # temp string is count + element
                s += str(cnt) + res[j]
                j += 1
            res = s
            n -= 1
        return res
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    string countAndSay(int n) {
        if (n == 0) return NULL;
        
        string res = "1";       // start at 1
        
        while (n != 1) {
            string cur = "";
            for (int i = 0; i < res.size(); ++i) {
                int cnt = 1;
                while ( (i+1) < res.size() && res[i] == res[i+1] ) {        // count res[i]
                    ++cnt;
                    ++i;
                }
                cur += to_string(cnt) + res[i];                             // count and say res[i]
            }
            res = cur;      // update current result
            --n;            // decrease n until n = 1
        }
        
        return res;
    }
};
\end{lstlisting}


\section{Length of Last Word (E)}
Given a string s consists of upper/lower-case alphabets and empty space characters ` ', return the length of last word in the string. If the last word does not exist, return 0. A word is defined as a character sequence consists of non-space characters only. \\

\begin{lstlisting}
class Solution {
public:
    int lengthOfLastWord(string s) {
        if (s.empty()) return 0;
        
        int cnt = 0, n = s.size() - 1;
        
        while (s[n] == ' ' && n >= 0) {
            --n;
        }
        
        while (s[n] != ' ' && n >= 0) {
            ++cnt;
            --n;
        }
        
        return cnt;
    }
};
\end{lstlisting}


\section{Longest Common Prefix (E)}
Write a function to find the longest common prefix string amongst an array of strings. \\

\begin{lstlisting}
class Solution {
public:
    string longestCommonPrefix(vector<string> &strs) {
        string prefix = "";                         // define the initial prefix
        if (strs.size() == 0)   return prefix;
        
        int i, j;
        // iterate different chars in the first string
        for (i = 0; i < strs[0].size(); ++i) { 
            
            // iterate different strings from the second string
            for (j = 1; j < strs.size() && i < strs[j].size(); ++j) {     
                if (strs[j][i] != strs[0][i])        // compare each char between the first string and the other strings
                    return prefix;                  // if no match for the current char, return prefix immediately
            }
            
            if (j == strs.size())                   // if the i-th char in the first string matches all others strings
                prefix += strs[0][i];               // update prefix
        }
        return prefix;
    }
};
\end{lstlisting}


\section{Implement strStr() (E)}
Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. \\

\begin{lstlisting}
class Solution(object):
    def strStr(self, haystack, needle):
        """
        :type haystack: str
        :type needle: str
        :rtype: int
        """
        m, n = len(haystack), len(needle)
        for i in range(m - n + 1):
            if haystack[i:i+n] == needle:
                return i
        return -1
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    int strStr(string haystack, string needle) {
        if (needle.empty()) return 0;

        for (int i = 0; ; ++i) {
            for (int j = 0; ; ++j) {
                if (needle[j] == '\0')          // if the current j reaches the end of needle, i is the correct index
                    return i;
                if (haystack[i + j] == '\0')    // if i+j reaches the end of haystack, there is no chance to find the needle
                    return -1;
                if (haystack[i + j] != needle[j])   // break for each no-match
                    break;
            }
        }
    }
};
\end{lstlisting}


\section{Is Subsequence (M)}
Given a string s and a string t, check if s is subsequence of t. You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string ($\leq$100).\\

A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ace" is a subsequence of "abcde" while "aec" is not).\\

Example 1:
s = "abc", t = "ahbgdc"
Return true.\\

Example 2:
s = "axc", t = "ahbgdc"
Return false.\\

Follow up:
If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?\\

\begin{lstlisting}
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int i = 0, j = 0;
        while (i < s.size() && j < t.size()) {
            if (s[i] == t[j]) ++i;
            ++j;
        }
        if (i == s.size()) return true;
        else return false;
    }
};
\end{lstlisting}


\section{Ransom Note (E)}
Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. \\

Note:
You may assume that both strings contain only lowercase letters.\\

canConstruct("a", "b") $->$ false\\
canConstruct("aa", "ab") $->$ false\\
canConstruct("aa", "aab") $->$ true\\

\begin{lstlisting}
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        unordered_map<char, int> m;
        for (auto c : magazine) ++m[c];
        for (auto c : ransomNote) {
            if (--m[c] < 0) return false;
        }
        return true;
    }
};
\end{lstlisting}


\section{Find the Difference (M)}
Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. \\

Example:\\
Input: s = "abcd", t = "abcde"\\
Output: e\\
Explanation: 'e' is the letter that was added.\\

\begin{lstlisting}
class Solution {
public:
    char findTheDifference(string s, string t) {
        unordered_map<char, int> m;
        for (auto c : s) ++m[c];
        for (auto c : t) {
            if (--m[c] < 0) return c;
        }
        return 0;
    }
};
\end{lstlisting}


\section{First Unique Character in a String (E)}
Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\\

Examples:\\
s = "leetcode"
return 0.\\
s = "loveleetcode",
return 2.\\

Note: You may assume the string contain only lowercase letters. \\

\begin{lstlisting}
class Solution(object):
    def firstUniqChar(self, s):
        """
        :type s: str
        :rtype: int
        """
        # Initialize the dictionary with keys from s and values as 0
        d = dict.fromkeys(s, 0)
        for c in s:
            d[c] += 1
        for c in s:
            if d[c] == 1:
                return s.index(c)
        return -1
\end{lstlisting}
        

\begin{lstlisting}
// 1. Brute-force with scanning s twice
class Solution {
public:
    int firstUniqChar(string s) {
        if (s.empty()) return -1;
        unordered_map<char, int> m;
        for (auto c : s) ++m[c];
        for (int i = 0; i < s.size(); ++i) {
            if (m[s[i]] == 1) return i;
        }
        return -1;
    }
};

// 2. Brute-force with scanning s only once
class Solution {
public:
    int firstUniqChar(string s) {
        if (s.empty()) return -1;
        unordered_map<char, pair<int, int>> m;
        int idx = s.size();
        for (int i = 0; i < s.size(); ++i) {
            m[s[i]].first++;     // save the count of chars
            m[s[i]].second = i;  // save the index of chars
        }
        for (auto a : m) {
            if (a.second.first == 1) {
                idx = min(idx, a.second.second); // find the smallest index
            }
        }
        return idx == s.size() ? -1 : idx;
    }
};
\end{lstlisting}

\section{Permutation in String (M)}
Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.

\begin{lstlisting}
class Solution(object):
    def checkInclusion(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: bool
        """
        m1, m2 = [0] * 26, [0] * 26
        n1, n2 = len(s1), len(s2)
        if n1 > n2: return False
        
        # count the frequency of each char for s1 and the first n1 chars of s2 
        # if the two counts are the same, then s2 contains the permuation of s1
        for i in range(n1):
            m1[ord(s1[i]) - ord('a')] += 1
            m2[ord(s2[i]) - ord('a')] += 1
        if m1 == m2: return True
        
        # apply the sliding window to check if the counts between
        # the length n1 substring of s2 and s1 are the same
        for i in range(n1, n2):
            m2[ord(s2[i]) - ord('a')] += 1
            m2[ord(s2[i - n1]) - ord('a')] -= 1
            if m1 == m2: return True
            
        return False
\end{lstlisting}

\section{ZigZag Conversion (E)}
Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows). \\
convert(``PAYPALISHIRING", 3) should return ``PAHNAPLSIIGYIR". \\

\begin{lstlisting}
class Solution {
public:
    string convert(string s, int numRows) {
        if (numRows <= 1)  return s;
        
        vector<string> tmp(numRows);
        string res;
        int row = 0, flag = 1;
        
        for (int i = 0; i < s.size(); ++i) {
            tmp[row].push_back(s[i]);
            
            // perform zigzag
            if (row == 0)                   // increase row number
                flag = 1;
            else if (row == numRows - 1)    // decrease row number
                flag = -1;
            row += flag;
        }
        
        for (int i = 0; i < numRows; ++i)
            res.append(tmp[i]);
            
        return res;
    }
};
\end{lstlisting}


\section{Group Shifted Strings (E)}
Given a string, we can ``shift" each of its letter to its successive letter, for example: $``abc" -> ``bcd"$. We can keep ``shifting" which forms the sequence: $"abc" -> "bcd" -> ... -> "xyz"$\\

Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.\\
For example, given: ["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"], \\
Return:
[
  ["abc","bcd","xyz"],
  ["az","ba"],
  ["acef"],
  ["a","z"]
] \\

Note: For the return value, each inner list's elements must follow the lexicographic order.\\

\begin{lstlisting}
class Solution {
public:
    vector<vector<string>> groupStrings(vector<string>& strings) {
        vector<vector<string> > res;
        unordered_map<string, multiset<string>> m;
        for (auto a : strings) {
            string t = "";
            for (char c : a) {
                t += to_string((c + 26 - a[0]) % 26) + ",";
            }
            m[t].insert(a);
        }
        for (auto it = m.begin(); it != m.end(); ++it) {
            res.push_back(vector<string>(it->second.begin(), it->second.end()));
        }
        return res;
    }
};
\end{lstlisting}


\section{Compare Version Numbers (E)}
Compare two version numbers version1 and version2. If version1 $>$ version2 return 1, if version1 $<$ version2 return -1, otherwise return 0.\\

You may assume that the version strings are non-empty and contain only digits and the . character.
The . character does not represent a decimal point and is used to separate number sequences.
For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision.\\

Here is an example of version numbers ordering: $0.1 < 1.1 < 1.2 < 13.37$\\

\begin{lstlisting}
class Solution(object):
    def compareVersion(self, version1, version2):
        """
        :type version1: str
        :type version2: str
        :rtype: int
        """
        v1_list = version1.split('.')
        v2_list = version2.split('.')
        max_len = max(len(v1_list), len(v2_list))
        for i in range(max_len):
            v1_int = int(v1_list[i]) if i < len(v1_list) else 0
            v2_int = int(v2_list[i]) if i < len(v2_list) else 0
            if v1_int < v2_int:
                return -1
            elif v1_int > v2_int:
                return 1
        return 0
\end{lstlisting}
        

\begin{lstlisting}
class Solution {
public:
    int compareVersion(string version1, string version2) {
        int n1 = version1.size(), n2 = version2.size();
        int i, j, num1, num2;
        i = j = num1 = num2 = 0;
        
        //first compare the left part before ".", then compare the right part after "."
        while (i < n1 || j < n2) {
            while (i < n1 && version1[i] != '.')
                num1 = num1 * 10 + (version1[i++] - '0');   // string to int

            while (j < n2 && version2[j] != '.')
                num2 = num2 * 10 + (version2[j++] - '0');
            
            if (num1 > num2)
                return 1;
            else if (num1 < num2)
                return -1;
            
            num1 = num2 = 0;
            ++i;
            ++j;
        }
        
        return 0;
    }
};
\end{lstlisting}


\section{Additive Number (M)}
Additive number is a string whose digits can form additive sequence. A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.\\

For example:\\

"112358" is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8.\\
1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\\

"199100199" is also an additive number, the additive sequence is: 1, 99, 100, 199.\\
1 + 99 = 100, 99 + 100 = 199\\

Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.\\

Given a string containing only digits '0'-'9', write a function to determine if it's an additive number.\\

Follow up:
How would you handle overflow for very large input integers? \\

\begin{lstlisting}
// Non-recursion
class Solution {
public:
    bool isAdditiveNumber(string num) {
        for (int i = 1; i < num.size(); ++i) {
            for (int j = i + 1; j < num.size(); ++j) {
                string s1 = num.substr(0, i);
                string s2 = num.substr(i, j - i);
                long long d1 = atoll(s1.c_str()), d2 = atoll(s2.c_str());
                if ((s1.size() > 1 && s1[0] == '0') || (s2.size() > 1 && s2[0] == '0')) continue;
                long long next = d1 + d2;
                string nexts = to_string(next);
                string now = s1 + s2 + nexts;
                while (now.size() < num.size()) {
                    d1 = d2;
                    d2 = next;
                    next = d1 + d2;
                    nexts = to_string(next);
                    now += nexts;
                }
                if (now == num) return true;
            }
        }
        return false;
    }
};
\end{lstlisting}


\section{Evaluate Division (M)}
Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.\\

Example:\\
Given a / b = 2.0, b / c = 3.0.\\
queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .\\
return [6.0, 0.5, -1.0, 1.0, -1.0 ].\\

According to the example above:\\
equations = [ ["a", "b"], ["b", "c"] ],\\
values = [2.0, 3.0],\\
queries = [ ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ]. \\

The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction. \\

\begin{lstlisting}
class Solution {
public:
    vector<double> calcEquation(vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries) {
        vector<double> res(queries.size(), -1);
        set<string> s;
        for (auto a : equations) {
            s.insert(a.first);
            s.insert(a.second);
        }
        for (int i = 0; i < queries.size(); ++i) {
            vector<string> query{queries[i].first, queries[i].second};
            if (s.count(query[0]) && s.count(query[1])) {
                vector<int> v;
                res[i] = helper(equations, values, query, v);
            }   
        }
        return res;
    }
    double helper(vector<pair<string, string>> equations, vector<double>& values, vector<string> query, vector<int>& v) {
        for (int i = 0; i < equations.size(); ++i) {
            if (equations[i].first == query[0] && equations[i].second == query[1]) return values[i];
            if (equations[i].first == query[1] && equations[i].second == query[0]) return 1.0 / values[i];
        }
        for (int i = 0; i < equations.size(); ++i) {
            if (find(v.begin(), v.end(), i) == v.end() && equations[i].first == query[0]) {
                v.push_back(i);
                double t = values[i] * helper(equations, values, {equations[i].second, query[1]}, v);
                if (t > 0) return t;
                else v.pop_back();
            }
            if (find(v.begin(), v.end(), i) == v.end() && equations[i].second == query[0]) {
                v.push_back(i);
                double t = helper(equations, values, {equations[i].first, query[1]}, v) / values[i];
                if (t > 0) return t;
                else v.pop_back();
            }
        }
        return -1.0;
    }
};


class Solution {
public:
    vector<double> calcEquation(vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries) {
        vector<double> res;
        unordered_map<string, unordered_map<string, double>> g;
        for (int i = 0; i < equations.size(); ++i) {
            g[equations[i].first].emplace(equations[i].second, values[i]);
            g[equations[i].first].emplace(equations[i].first, 1.0);
            g[equations[i].second].emplace(equations[i].first, 1.0 / values[i]);
            g[equations[i].second].emplace(equations[i].second, 1.0);
        }
        for (auto query : queries) {
            if (!g.count(query.first) || !g.count(query.second)) res.push_back(-1.0);
            else {
                queue<pair<string, double>> q;
                unordered_set<string> used{query.first};
                bool find = false;
                q.push({query.first, 1.0});
                while (!q.empty() && !find) {
                    queue<pair<string, double>> next;
                    while (!q.empty() && !find) {
                        pair<string, double> t = q.front(); q.pop();
                        if (t.first == query.second) {
                            find = true;
                            res.push_back(t.second);
                            break;
                        }
                        for (auto a : g[t.first]) {
                            if (!used.count(a.first)) {
                                a.second *= t.second;
                                next.push(a);
                                used.insert(a.first);
                            }
                        }
                    }
                    q = next;
                }
                if (!find) res.push_back(-1.0);
            }
        }
        return res;
    }
};
\end{lstlisting}


\section{Restore IP Addresses (M)}
Given a string containing only digits, restore it by returning all possible valid IP address combinations.\\

For example:
Given "25525511135",
return ["255.255.11.135", "255.255.111.35"]. (Order does not matter) \\

\begin{lstlisting}
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        vector<string> res;
        restore(s, 4, "", res);
        return res;
    }
    void restore(string s, int k, string out, vector<string> &res) {
        if (k == 0) {
            if (s.empty()) res.push_back(out);
        }
        else {
            for (int i = 1; i <= 3; ++i) {
                if (s.size() >= i && isValid(s.substr(0, i))) {
                    if (k == 1) restore(s.substr(i), k - 1, out + s.substr(0, i), res);
                    else restore(s.substr(i), k - 1, out + s.substr(0, i) + ".", res);
                }
            }
        }
    }
    bool isValid(string s) {
        if (s.empty() || s.size() > 3 || (s.size() > 1 && s[0] == '0')) return false;
        int res = atoi(s.c_str());
        return res <= 255 && res >= 0;
    }
};
\end{lstlisting}


\section{Simplify Path (M)}
Given an absolute path for a file (Unix-style), simplify it.\\

For example,\\
path = "/home/", $->$ "/home"\\
path = "/a/./b/../../c/", $->$ "/c"\\

Corner Cases:\\
    Did you consider the case where path = "/../"?\\
    In this case, you should return "/".\\
    Another corner case is the path might contain multiple slashes '/' together, such as "/home//foo/".\\
    In this case, you should ignore redundant slashes and return "/home/foo".\\

\begin{lstlisting}
class Solution(object):
    def simplifyPath(self, path):
        """
        :type path: str
        :rtype: str
        """
        path = path.split("/")
        st = []
        for i in path:
            if i == '.' or not i: continue
            elif i == '..':
                if st: st.pop()
                else: continue
            else: st.append(i)
        return "/" + "/".join(st)
\end{lstlisting}
            
\begin{lstlisting}
class Solution {
public:
    string simplifyPath(string path) {
        vector<string> v;
        int i = 0;
        while (i < path.size()) {
            while (path[i] == '/' && i < path.size()) ++i;
            if (i == path.size()) break;
            int start = i;
            while (path[i] != '/' && i < path.size()) ++i;
            int end = i - 1;
            string s = path.substr(start, end - start + 1);
            if (s == "..") {
                if (!v.empty()) v.pop_back(); 
            } else if (s != ".") {
                v.push_back(s);
            }
        }
        if (v.empty()) return "/";
        string res;
        for (int i = 0; i < v.size(); ++i) {
            res += '/' + v[i];
        }
        return res;
    }
};

class Solution {
public:
    string simplifyPath(string path) {
        string res, t;
        stringstream ss(path);
        vector<string> v;
        while (getline(ss, t, '/')) {
            if (t == "" || t == ".") continue;
            if (t == ".." && !v.empty()) v.pop_back();
            else if (t != "..") v.push_back(t);
        }
        for (string s : v) res += "/" + s;
        return res.empty() ? "/" : res;
    }
};
\end{lstlisting}


\section{Longest Absolute File Path (M)}
Suppose we abstract our file system by a string in the following manner:\\

The string "dir/n/tsubdir1/n/tsubdir2/n/t/tfile.ext" represents:\\
dir\\
    subdir1\\
    subdir2\\
        file.ext\\
The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext.\\

The string "dir/n/tsubdir1/n/t/tfile1.ext/n/t/tsubsubdir1/n/tsubdir2/n/t/tsubsubdir2/n/t/t/tfile2.ext" represents:\\
dir\\
    subdir1\\
        file1.ext\\
        subsubdir1\\
    subdir2\\
        subsubdir2\\
            file2.ext\\
The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext.\\

We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is "dir/subdir2/subsubdir2/file2.ext", and its length is 32 (not including the double quotes).\\

Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0.\\

Note:\\
    The name of a file contains at least a . and an extension.\\
    The name of a directory or sub-directory will not contain a ..\\
Time complexity required: O(n) where n is the size of the input string.\\
Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path \\
aaaaaaaaaaaaaaaaaaaaa/sth.png.\\

\begin{lstlisting}
class Solution {
public:
    int lengthLongestPath(string input) {
        int res = 0, n = input.size(), level = 0;
        unordered_map<int, int> m {{0, 0}};
        for (int i = 0; i < n; ++i) {
            int start = i;
            // find a directory or a file
            while (i < n && input[i] != '\n' && input[i] != '\t') ++i;
            if (i >= n || input[i] == '\n') {
                string t = input.substr(start, i - start); // get the file name
                if (t.find('.') != string::npos) { // update res if we find a file
                    res = max(res, m[level] + (int)t.size());
                } else { // update level if we find a directory
                    ++level;
                    m[level] = m[level - 1] + (int)t.size() + 1;
                }
                level = 0;
            } else {
                ++level;
            }
        }
        return res;
    }
};

class Solution {
public:
    int lengthLongestPath(string input) {
        int res = 0;
        istringstream ss(input);
        unordered_map<int, int> m {{0, 0}};
        string line;
        while (getline(ss, line)) {
            auto pos = line.find_last_of('\t');
            string t = (pos != string::npos) ? line.substr(pos + 1) : line;
            int level = line.size() - t.size();
            if (line.find('.') != string::npos) {
                res = max(res, m[level] + (int)t.size());
            } else {
                m[level + 1] = m[level] + (int)t.size() + 1;
            }
        }
        return res;
    }
};
\end{lstlisting}


\section{Valid Parentheses (E)}
Given a string containing just the characters `(', `)', `\{', `\}', `[' and `]', determine if the input string is valid. The brackets must close in the correct order, ``()" and ``()[]\{\}" are all valid but ``(]" and ``([)]" are not.\\

\begin{lstlisting}
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        stack = []
        for bracket in s:
            if bracket == '(' or bracket == '[' or bracket =='{':
                stack.append(bracket)
            else:
                if not stack: return False
                if bracket == ')' and stack[-1] != '(': return False
                if bracket == ']' and stack[-1] != '[': return False
                if bracket == '}' and stack[-1] != '{': return False
                stack.pop()
        return not stack    
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    bool isValid(string s) {
        stack<char> tmp;
        
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] == '(' || s[i] == '[' || s[i] == '{') {
                tmp.push(s[i]);
            } else if ( (!tmp.empty() && tmp.top() == '(' && s[i] == ')') ||
                        (!tmp.empty() && tmp.top() == '[' && s[i] == ']') ||                                               
                        (!tmp.empty() && tmp.top() == '{' && s[i] == '}') ){
                tmp.pop();
            } else {
                return false;
            }
        }
        
        return tmp.empty();
    }
};
\end{lstlisting}


\section{Generate Parentheses (M)}
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. \\
 
 \begin{lstlisting}
 class Solution(object):
    def generateParenthesis(self, n):
        """
        :type n: int
        :rtype: List[str]
        """
        out, res = '', []
        self.gen(n, n, '', res)
        return res
    def gen(self, left, right, out, res):
        if left > right: return
        if left == 0 and right == 0:
            res.append(out)
        else:
            if left > 0:
                self.gen(left-1, right, out+'(', res)
            if right > 0:
                self.gen(left, right-1, out+')', res)
\end{lstlisting}
 
\begin{lstlisting}
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> res;
        generate(res, "", n, 0);
        return res;
    }
    void generate(vector<string> &res, string str, int left, int right) {
        if (left == 0 && right == 0) {
            res.push_back(str);
            return;
        }
        if (right > 0) generate(res, str+")", left, right-1);
        if (left > 0) generate(res, str+"(", left-1, right+1);
    }
};
\end{lstlisting}


\section{Different Ways to Add Parentheses (M)}
Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.\\

Example: 
Input: ``2-1-1". \\
((2-1)-1) = 0\\
(2-(1-1)) = 2\\
Output: [0, 2]\\

\begin{lstlisting}
class Solution {
public:
    vector<int> diffWaysToCompute(string input) {
        vector<int> res;
        int n = input.size();
        
        for (int i = 0; i < n; ++i) {
            char c = input[i];
            if (c == '+' || c == '-' || c == '*') {
                vector<int> result1 = diffWaysToCompute(input.substr(0,i));
                vector<int> result2 = diffWaysToCompute(input.substr(i+1));
                for (int j = 0; j < result1.size(); ++j) {
                    for (int k = 0; k < result2.size(); ++k) {
                        switch (c) {
                            case '+':
                                res.push_back(result1[j] + result2[k]);
                                break;
                            case '-':
                                res.push_back(result1[j] - result2[k]);
                                break;
                            case '*':
                                res.push_back(result1[j] * result2[k]);
                                break;
                        }
                    }
                }
            }
        }
        
        if (res.empty())
            res.push_back(stoi(input));
            
        return res;
    }
};
\end{lstlisting}


\section{Longest Valid Parentheses (H)}
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. \\

For "(()", the longest valid parentheses substring is "()", which has length = 2.\\

Another example is ")()())", where the longest valid parentheses substring is "()()", which has length = 4. \\

\begin{lstlisting}
class Solution {
public:
    int longestValidParentheses(string s) {
        int maxlen = 0, last = -1;
        stack<int> tmp;
        
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] == '(') {
                tmp.push(i);                // push the index of '(' to stack
            } else {
                if (tmp.empty()) {          // if no match for the current ')'
                    last = i;               // update last index of '('
                } else {                    // if find a match for the current ')'
                    tmp.pop();              // pop the index of '('
                    if (tmp.empty()) {                              
                        maxlen = max(maxlen, i - last);
                    } else {
                        maxlen = max(maxlen, i - tmp.top());
                    }
                }
            }
        }
        
        return maxlen;
    }
};
\end{lstlisting}


\section{Remove Invalid Parentheses (H)}
Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results. \\

Note: The input string may contain letters other than the parentheses ( and ). \\

\begin{lstlisting}
class Solution(object):
    def removeInvalidParentheses(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        res = []
        idx = 0
        cnt1, cnt2 = 0, 0
        for c in s:
            if c == '(':
                cnt1 += 1
            elif c == ')':
                if cnt1 == 0: cnt2 += 1  # more ')' than '('
                else: cnt1 -= 1  # for each vaild pair just reduce cnt1
        self.bfs(s, idx, cnt1, cnt2, res)
        return res
    
    def bfs(self, s, idx, cnt1, cnt2, res):
        # if the string is vaild when the excess number of left or right 
        # parentheses is zero, save that string to res
        if cnt1 == 0 and cnt2 == 0:
            if self.isValid(s): res.append(s)
            return
        for i in range(idx, len(s)):
            # skip duplicated parentheses since the result is the same
            if i != idx and s[i] == s[i-1]: continue
            # for each excess parenthese, check the string without the it recursively
            if cnt1 > 0 and s[i] == '(':
                self.bfs(s[:i] + s[i+1:], i, cnt1 - 1, cnt2, res)
            if cnt2 > 0 and s[i] == ')':
                self.bfs(s[:i] + s[i+1:], i, cnt1, cnt2 - 1, res)

    def isValid(self, s):
        cnt = 0
        for c in s:
            if c == '(':
                cnt += 1
            elif c == ')':
                cnt -= 1
                if cnt < 0: return False
        return cnt == 0         
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    vector<string> removeInvalidParentheses(string s) {
        unordered_set<string> result;
        int left_removed = 0;
        int right_removed = 0;
        for(auto c : s) {
            if(c == '(') {
                ++left_removed;
            }
            if(c == ')') {
                if(left_removed != 0) {
                    --left_removed;
                }
                else {
                    ++right_removed;
                }
            }
        }
        helper(s, 0, left_removed, right_removed, 0, "", result);
        return vector<string>(result.begin(), result.end());
    }
private:
    void helper(string s, int index, int left_removed, int right_removed, int pair, string path, unordered_set<string>& result) {
        if(index == s.size()) {
            if(left_removed == 0 && right_removed == 0 && pair == 0) {
                result.insert(path);
            }
            return;
        }
        if(s[index] != '(' && s[index] != ')') {
            helper(s, index + 1, left_removed, right_removed, pair, path + s[index], result);
        }
        else {
            if(s[index] == '(') {
                if(left_removed > 0) {
                    helper(s, index + 1, left_removed - 1, right_removed, pair, path, result);
                }
                helper(s, index + 1, left_removed, right_removed, pair + 1, path + s[index], result);
            }
            if(s[index] == ')') {
                if(right_removed > 0) {
                    helper(s, index + 1, left_removed, right_removed - 1, pair, path, result);
                }
                if(pair > 0) {
                    helper(s, index + 1, left_removed, right_removed, pair - 1, path + s[index], result);
                }
            }
        }
    }
};
\end{lstlisting}


\section{Flip Game (E)}
You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive ``++" into ``- -". The game ends when a person can no longer make a move and therefore the other person will be the winner. Write a function to compute all possible states of the string after one valid move.\\

For example, given s = ``++++", after one move, it may become one of the following states:
[
  ``- -++",
  ``+- -+",
  ``++- -"
]
If there is no valid move, return an empty list [].\\

\begin{lstlisting}
class Solution {
public:
    vector<string> generatePossibleNextMoves(string s) {
        vector<string> res;
        for (int i = 1; i < s.size(); ++i) {
            if (s[i] == '+' && s[i-1] == '+'){
                res.push_back(s.substr(0, i-1) + "--" + s.substr(i+1)); // substr(pos, len);
            }
        }
        return res;
    }
};
\end{lstlisting}


\section{Flip Game II (M)}
You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive "++" into "--". The game ends when a person can no longer make a move and therefore the other person will be the winner. Write a function to determine if the starting player can guarantee a win.\\

For example, given s = "++++", return true. The starting player can guarantee a win by flipping the middle "++" to become "+--+".\\

\begin{lstlisting}
class Solution {
public:
    bool canWin(string s) {
        for (int i = 1; i < s.size(); ++i) {
            if (s[i] == '+' && s[i - 1] == '+' && !canWin(s.substr(0, i - 1) + "--" + s.substr(i + 1))) {
                return true;
            }
        }
        return false;
    }
};
\end{lstlisting}


\section{Excel Sheet Column Number (E)}
Given a column title as appear in an Excel sheet, return its corresponding column number.\\

For example:\\
$
    A -> 1 \\
    B -> 2 \\
    C -> 3 \\
    ... \\
    Z -> 26\\
    AA -> 27\\
    AB -> 28 $\\

\begin{lstlisting}
class Solution(object):
    def titleToNumber(self, s):
        """
        :type s: str
        :rtype: int
        """
        res = 0
        for i in range(0, len(s)):
            res = res * 26 + (ord(s[i]) - ord('A') + 1)
        return res
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    int titleToNumber(string s) {
        int result = 0;
        
        for (int i = 0; i < s.size(); ++i)
            result = result * 26 + (s[i] - 'A' + 1);
            
        return result;
    }
};
\end{lstlisting}


\section{Excel Sheet Column Title (E)}
Given a positive integer, return its corresponding column title as appear in an Excel sheet.\\

For example:\\
$
    1 -> A\\
    2 -> B\\
    3 -> C\\
    ...\\
    26 -> Z\\
    27 -> AA\\
    28 -> AB \\$
    
\begin{lstlisting}    
class Solution(object):
    def convertToTitle(self, n):
        """
        :type n: int
        :rtype: str
        """
        res = ''
        while n:
            res += chr((n - 1) % 26 + ord('A'))
            n = (n - 1) // 26
        return res[::-1]
\end{lstlisting}
        
\begin{lstlisting}
class Solution {
public:
    string convertToTitle(int n) {
        if (n <= 0)
            return NULL;
            
        string result;
        char tmp;
        
        while (n != 0) {
            n -= 1;
            tmp = n % 26 + 'A';
            result = tmp + result;            
            n /= 26;
        }
        
        return result;
    }
};
\end{lstlisting}   


\section{Roman to Integer (E)}
Given a roman numeral, convert it to an integer.\\

Input is guaranteed to be within the range from 1 to 3999.\\

Python:
\lstset{language=python}
\begin{lstlisting}
class Solution(object):
    def romanToInt(self, s):
        """
        :type s: str
        :rtype: int
        """
        d = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}
        res = 0
        for i in range(len(s)):
            val = d[s[i]]
            if (i + 1 == len(s)) or (d[s[i+1]] <= d[s[i]]):
                res += val
            else:
                res -= val
        return res
\end{lstlisting}   
        
C++:
\lstset{language=c++}
\begin{lstlisting}
class Solution {
public:
    int romanToInt(string s) {
        int n = s.size();
        if (n == 0)
            return 0;

        unordered_map<char, int> roman = {   { 'I' , 1 },
                                             { 'V' , 5 },
                                             { 'X' , 10 },
                                             { 'L' , 50 },
                                             { 'C' , 100 },
                                             { 'D' , 500 },
                                             { 'M' , 1000 } };
                                         
        int num = 0;
        for (int i = 0; i < n-1; ++i) {
            if (roman[s[i]] < roman[s[i+1]])
                num -= roman[s[i]];
            else
                num += roman[s[i]];
        }
    
        num += roman[s[n-1]];
    
        return num;
    }
};
\end{lstlisting}   


\section{Integer to Roman (M)}
Given an integer, convert it to a roman numeral. \\

Input is guaranteed to be within the range from 1 to 3999.\\

Python:
\begin{lstlisting}
class Solution(object):
    def intToRoman(self, num):
        """
        :type num: int
        :rtype: str
        """
        val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
        roman = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
        res = ''
        for i in range(len(val)):
            while num >= val[i]:
                num -= val[i]
                res += roman[i]
        return res
\end{lstlisting}   

C++:
\begin{lstlisting}
class Solution {
public:
    string intToRoman(int num) {
        int value[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        string symbol[] = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
        string result;
        int digit, idx = 0;
        
        while (num != 0) {
            digit = num / value[idx];
            num %= value[idx];
            while (digit != 0) {
                result += symbol[idx];
                --digit;
            }
            ++idx;
        }
        
        return result;
    }
};
\end{lstlisting}   

\section{Integer to English Words (H)}
Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than (2 to the power of 31) - 1.\\

\begin{lstlisting}
class Solution(object):
    def numberToWords(self, num):
        """
        :type num: int
        :rtype: str
        """
        if num == 0: return 'Zero'
        self.word1 = ['Zero', "One", "Two", "Three", "Four", "Five", "Six", "Seven", \
                      "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", \
                      "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", \
                      "Nineteen"]
        self.word2 = ['Zero', "Ten", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", \
                      "Seventy", "Eighty", "Ninety"]
        return self.int2str(num)[1:]
    def int2str(self, n):
        if n >= 10**9:
            return self.int2str(n / (10**9)) + ' Billion' + self.int2str(n % (10**9))
        elif n >= 10**6:
            return self.int2str(n / (10**6)) + ' Million' + self.int2str(n % (10**6))
        elif n >= 10**3:
            return self.int2str(n / (10**3)) + ' Thousand' + self.int2str(n % (10**3))
        elif n >= 10**2:
            return self.int2str(n / (10**2)) + ' Hundred' + self.int2str(n % (10**2))
        elif n >= 20:
            return ' ' + self.word2[n / 10] + self.int2str(n % 10)
        elif n >= 1:
            return ' ' + self.word1[n]
        else:
            return ''
\end{lstlisting}

\section{String to Integer (atoi) (E)}
Implement atoi to convert a string to an integer. \\

\begin{lstlisting}
class Solution(object):
    def myAtoi(self, str):
        """
        :type str: str
        :rtype: int
        """
        int_max = pow(2, 31) - 1
        int_min = -pow(2, 31)
        sign = 1
        res, pos = 0, 0
        n = len(str)
        
        # skip all whitespaces
        while pos < n and str[pos] == ' ':
            pos += 1
        
        # get the sign
        if pos < n and str[pos] == '-':
            sign = -1
            pos += 1
        elif pos < n and str[pos] == '+':
            pos += 1
            
        # get the numeral from the string
        while pos < n and \
              ord(str[pos]) >= ord('0') and \
              ord(str[pos]) <= ord('9'):
            num = ord(str[pos]) - ord('0')
            # handle overflow
            if res > int_max / 10 or (res == int_max / 10 and num >= 8): 
                if sign == 1:
                    return int_max
                else:
                    return int_min
            res = res * 10 + num
            pos += 1
        
        return sign * res
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    int myAtoi(string str) {
        int sign = 1, base = 0, i = 0;
        
        while (str[i] == ' ')           // ignor whitespace
            ++i;
        
        if (str[i] == '-') {            // get the sign
            sign = -1;
            ++i;
        } else if (str[i] == '+'){
            sign = 1;
            ++i;
        }
        
        while (str[i] >= '0' && str[i] <= '9') {
            // catch the max int or min int case
            if (base > INT_MAX / 10 || (base == INT_MAX / 10 && str[i] - '0' > 7)) {
                if (sign == 1) 
                    return INT_MAX;
                else 
                    return INT_MIN;
            }
            
            base = 10 * base + (str[i++] - '0');
        }
        
        return base * sign;
    }
};
\end{lstlisting}  


\section{Reverse String (E)}
Write a function that takes a string as input and returns the string reversed. \\

Example: Given s = "hello", return "olleh". \\

\begin{lstlisting}
class Solution(object):
    def reverseString(self, s):
        """
        :type s: List[str]
        :rtype: None Do not return anything, modify s in-place instead.
        """
        if not s: return
        left = 0
        right = len(s) - 1
        while left < right:
            t = s[left]
            s[left] = s[right]
            s[right] = t
            left += 1
            right -= 1
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    string reverseString(string s) {
        int start = 0, end = s.length()-1;
        char tmp;
        while (start < end) {
            tmp = s[start];
            s[start++] = s[end];
            s[end--] = tmp;
        }
        return s;
    }
};
\end{lstlisting}

\section{Reverse String II (E)}
Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original. 

\begin{lstlisting}
class Solution(object):
    def reverseStr(self, s, k):
        a = list(s)
        for i in xrange(0, len(a), 2*k):
            a[i:i+k] = reversed(a[i:i+k])
        return "".join(a)
\end{lstlisting}

\section{Reverse Vowels of a String (E)}
Write a function that takes a string as input and reverse only the vowels of a string. \\

Example 1:
Given s = "hello", return "holle". \\

Example 2:
Given s = "leetcode", return "leotcede". \\

\begin{lstlisting}
class Solution {
public:
    bool isVowel(char c) {
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';
    }
    
    string reverseVowels(string s) {
        int i = 0, j = s.length() - 1;
        
        while (i < j) {
            while (!isVowel(s[i]))
                ++i;
            while (!isVowel(s[j]))
                --j;
            if (i < j) {
                swap(s[i], s[j]);
                ++i;
                --j;
            }
        }
        
        return s;
    }
};
\end{lstlisting}


\section{Reverse Words in a String (M)}
Given an input string, reverse the string word by word.\\

For example,
Given s = "the sky is blue",
return "blue is sky the". \\

For C programmers: Try to solve it in-place in O(1) space.\\

Clarification:\\
    What constitutes a word?\\
    A sequence of non-space characters constitutes a word.\\
    Could the input string contain leading or trailing spaces?\\
    Yes. However, your reversed string should not contain leading or trailing spaces.\\
    How about multiple spaces between two words?\\
    Reduce them to a single space in the reversed string.\\

\begin{lstlisting}
class Solution(object):
    def reverseWords(self, s):
        """
        :type s: str
        :rtype: str
        """
        res = ''
        words = s.split(' ')
        for i in range(len(words)-1, -1, -1):
            res += words[i] + ' '
        return ' '.join(res.split())
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    void reverseWords(string &s) {
        int i = 0, j = 0, k = 0, wordCount = 0;
        while (true) {
            while (i < s.size() && s[i] == ' ') ++i;
            if (i == s.size()) break; // break if space is the last char
            if (wordCount) s[j++] = ' ';
            k = j;
            while (i < s.size() && s[i] != ' ') {
                s[j] = s[i];
                ++j; 
                ++i;
            }
            reverseWord(s, k, j - 1); // reverse the word
            ++wordCount; // increase counter
        }
        s.resize(j); // resize the new string based on the index of j
        reverseWord(s, 0, j - 1); // reverse the whole string
    }
    void reverseWord(string &s, int i, int j) {
        while (i < j) {
            char t = s[i];
            s[i++] = s[j];
            s[j--] = t;
        }
    }
};
\end{lstlisting}


\section{Reverse Words in a String II (M)}
Given an input string, reverse the string word by word. \\

Example:\\

Input:  ["t","h","e"," ","s","k","y"," ","i","s"," ","b","l","u","e"]\\
Output: ["b","l","u","e"," ","i","s"," ","s","k","y"," ","t","h","e"]\\

A word is defined as a sequence of non-space characters. The input string does not contain leading or trailing spaces and the words are always separated by a single space.\\

For example,
Given s = "the sky is blue",
return "blue is sky the".\\

Could you do it in-place without allocating extra space? \\

\begin{lstlisting}
class Solution(object):
    def reverseWords(self, s):
        """
        :type s: str
        :rtype: str
        """
        left = 0
        n = len(s)
        self.reverse(s, 0, n - 1)
        for i in range(n):
            if i == n or s[i] = ' ':
                self.reverse(s, left, i - 1)
                left = i + 1
    def reverse(s, left, right):
        while left < right:
            t = s[left]
            s[left] = s[right]
            s[right] = t
            left += 1
            right -= 1
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    void reverseWords(string &s) {
        int pos = 0;
        for (int i = 0; i <= s.size(); ++i) {
            if (i == s.size() || s[i] == ' ') {
                reverse(s, pos, i - 1);
                pos = i + 1;
            }
        }
        reverse(s, 0, s.size() - 1);
    }
    void reverse(string &s, int left, int right) {
        while (left < right) {
            char t = s[left];
            s[left++] = s[right];
            s[right--] = t;
        }
    }
};
\end{lstlisting}

\section{Reverse Words in a String III (E)}
Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\\

Example: \\
Input: "Let's take LeetCode contest"\\
Output: "s'teL ekat edoCteeL tsetnoc"\\

Note: In the string, each word is separated by single space and there will not be any extra space in the string. \\

\begin{lstlisting}
class Solution(object):
    def reverseWords(self, s):
        """
        :type s: str
        :rtype: str
        """
        words = s.split(' ')
        res = []
        for w in words:
            res.append(w[::-1])
        return ' '.join(res)
\end{lstlisting}

\section{Valid Anagram (E)}
Given two strings s and t, write a function to determine if t is an anagram of s.\\

For example,\\
s = ``anagram", t = ``nagaram", return true.\\
s = ``rat", t = ``car", return false.\\

Note:\\
You may assume the string contains only lowercase alphabets.\\

Follow up:\\
What if the inputs contain unicode characters? How would you adapt your solution to such case?\\

\begin{lstlisting}
class Solution(object):
    def isAnagram(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: bool
        """
        if len(s) != len(t): return False
        m = {}
        for char in s:
            if char in m:
                m[char] += 1
            else:
                m[char] = 1
        for char in t:
            if char in m and m[char] != 0:
                m[char] -= 1
            else:
                return False
        return True
 
class Solution(object):
    def isAnagram(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: bool
        """
        if len(s) != len(t): return False
        m = [0 for i in range(26)]
        for i in range(len(s)):
            m[ord(s[i]) - ord('a')] += 1
            m[ord(t[i]) - ord('a')] -= 1
        for v in m:
            if v != 0: return False
        return True
\end{lstlisting}

\begin{lstlisting}
// unordered_map<Key,T>::iterator it;
// (*it).first;             // the key value (of type Key)
// (*it).second;            // the mapped value (of type T)
// (*it);                   // the "element value" (of type pair<const Key,T>)

// Sol1: Hash table
class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.length() != t.length())
            return false;
            
        unordered_map<char,int> counts;
        for (int i = 0; i < s.length(); ++i) {
            ++counts[s[i]];
            --counts[t[i]];
        }
        for (auto count : counts) {
            if (count.second)
                return false;
        }
        return true;
    }
};

// Sol2: Optimization by the fix-size array
class Solution {
public:
     bool isAnagram(string s, string t) {
         if(s.length() != t.length())
             return false;
            
         int counts[26] = {0};
         for (int i = 0; i < s.length(); ++i) {
             ++counts[s[i] - 'a'];
             --counts[t[i] - 'a'];
         }
         for (int i = 0; i < 26; ++i) {
             if (counts[i])
                 return false;
         }
         return true;
     }
};
\end{lstlisting}


\section{Group Anagrams (M)}
Given an array of strings, group anagrams together.\\

For example, given: ["eat", "tea", "tan", "ate", "nat", "bat"],\\
Return:
[
  ["ate", "eat","tea"],
  ["nat","tan"],
  ["bat"]
].\\

Note: All inputs will be in lower-case.\\
\begin{lstlisting}
class Solution(object):
    def groupAnagrams(self, strs):
        """
        :type strs: List[str]
        :rtype: List[List[str]]
        """
        m, res = {}, []
        # key: val -> sorted string: list of strings
        for s in strs:
            key = ''.join(sorted(s))
            if key in m:
                m[key].append(s)
            else:
                m[key] = [s]
        for key in m:
            res.append(m[key])
        return res
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> group;

        for (string s : strs) {
            string key = s; 
            sort(key.begin(), key.end());
            group[key].push_back(s);
        }
        
        vector<vector<string>> anagrams;
        for (auto g : group)
            anagrams.push_back(g.second);
        
        return anagrams;
    }
};
\end{lstlisting}


\section{Valid Palindrome (E)}
Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. \\

For example,\\
``A man, a plan, a canal: Panama" is a palindrome.\\
``race a car" is not a palindrome. \\

Python:
\lstset{language=python}
\begin{lstlisting}
class Solution(object):
    def isPalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """
        if not s: return True
        n = len(s)
        left, right = 0, n - 1
        while left < right:
            if not s[left].isalnum(): 
                left += 1
            elif not s[right].isalnum():
                right -= 1
            elif s[left].lower() == s[right].lower():
                left += 1
                right -= 1
            else: 
                return False
        return True
\end{lstlisting}

C++:
\lstset{language=C++}
\begin{lstlisting}
class Solution {
public:
    bool isPalindrome(string s) {
        
        int start = 0, end = s.size()-1;
        
        while (start < end) {
            if (isalnum(s[start]) == false)         // isalnum: checks whether c is an alphanumeric character
                ++start;
            else if (isalnum(s[end]) == false)
                --end;        
            else if (tolower(s[start++]) != tolower(s[end--]))      // tolower: Converts parameter c to its lowercase equivalent if c is an uppercase letter and has a lowercase equivalent
                return false;
        }
        
        return true;
    }
};
\end{lstlisting}

\section{Valid Palindrome II (E)}
Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome. \\

Examples:\\
Input: "aba", Output: True\\
Input: "abca", Output: True\\

Python:
\lstset{language=python}
\begin{lstlisting}
# O(N^2)
class Solution(object):
    def validPalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """
        n = len(s)
        for i in range(n):
            t = s[:i] + s[i+1:n]
            if t == t[::-1]: return True
        return s == s[::-1]

# O(N)
class Solution(object):
    def validPalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """
        n = len(s)
        left, right = 0, n - 1
        while left < right:
            if s[left] != s[right]:
                return self.isValid(s, left+1, right) or self.isValid(s, left, right-1)
            left += 1
            right -= 1
        return True
    def isValid(self, s, left, right):
        while left < right:
            if s[left] != s[right]: return False
            left += 1
            right -= 1
        return True
\end{lstlisting}


\section{Palindromic Substrings (M)}
Given a string, your task is to count how many palindromic substrings in this string.\\

The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.\\

Example1:\\
Input: "abc", Output: 3 \\
Explanation: Three palindromic strings: "a", "b", "c".\\

Input: "aaa", Output: 6\\
Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".\\

Python:
\lstset{language=python}
\begin{lstlisting}
# O(N^2)
class Solution(object):
    def countSubstrings(self, s):
        """
        :type s: str
        :rtype: int
        """
        if not s: return 0
        n = len(s)
        res = 0
        for i in range(n):
            res = self.findPal(s, n, i, i, res)
            res = self.findPal(s, n, i, i+1, res)
        return res
    def findPal(self, s, n, i, j, res):
        while i >= 0 and j < n and s[i] == s[j]:
            res += 1
            i -= 1
            j += 1
        return res
    
# # DP with bugs: O(N^2)
# class Solution(object):
#     def countSubstrings(self, s):
#         """
#         :type s: str
#         :rtype: int
#         """
#         n = len(s)
#         res = 0
#         dp = [[0] * n] * n
#         for i in range(n-1, -1, -1):
#             for j in range(i, n, 1):
#                 if s[i] == s[j] and (j - i <= 2 or dp[i+1][j-1] == 1):
#                     dp[i][j] = 1
#                     res += 1
#         return res             
        

\end{lstlisting}
\lstset{language=C++}

\section{Longest Palindromic Substring (M)}
Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.\\

Python:
\lstset{language=python}
\begin{lstlisting}
# O(N^2)
class Solution(object):
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        n = len(s)
        start, max_lps_len = 0, 1
        if n < 2: return s 
        # check both cases when the substring length is either odd or even
        for i in range(n-1):
            start, max_lps_len = self.findLPS(s, n, i, i, start, max_lps_len)
            start, max_lps_len = self.findLPS(s, n, i, i + 1, start, max_lps_len)
        return s[start: start + max_lps_len]
    
    def findLPS(self, s, s_len, left, right, start, max_lps_len):
        while left >= 0 and right < s_len and s[left] == s[right]:
            left -= 1
            right += 1
        # the actual left and right here are outside of the lsp substring
        if max_lps_len < right - left - 1:
            start = left + 1
            max_lps_len = right - left - 1
        return start, max_lps_len
    
# DP: O(N^2) for both time and space complexity
import numpy as np
class Solution(object):
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        n = len(s)
        dp = np.zeros(shape=(n,n))
        if n >= 1:
            start, max_len = 0, 1
        else:
            return ''
        for i in range(n):
            dp[i][i] = 1
            for j in range(i):
                if i - j < 2:
                    if s[i] == s[j]: dp[j][i] = 1
                else:
                    if s[i] == s[j] and dp[j+1][i-1] == 1: dp[j][i] = 1
                if (dp[j][i] == 1) and (max_len < i - j + 1):
                    max_len = i - j + 1
                    start = j
        return s[start: start + max_len]
\end{lstlisting}

C++:
\lstset{language=C++}
\begin{lstlisting}
// Time complexity O(n*n)
class Solution {
public:
    string longestPalindrome(string s) {
        int startIdx = 0, left = 0, right = 0, len = 0;
        for (int i = 0; i < s.size() - 1; ++i) {
            if (s[i] == s[i + 1]) {
                left = i;
                right = i + 1;
                searchPalindrome(s, left, right, startIdx, len);
            }
            left = right = i;
            searchPalindrome(s, left, right, startIdx, len);
        }
        if (len == 0) len = s.size();
        return s.substr(startIdx, len);
    }
    void searchPalindrome(string s, int left, int right, int &startIdx, int &len) {
        int step = 1;
        while ((left - step) >= 0 && (right + step) < s.size()) {
            if (s[left - step] != s[right + step]) break;
            ++step;
        }
        int wide = right - left + 2 * step - 1;
        if (len < wide) {
            len = wide;
            startIdx = left - step + 1;
        }
    }
};

// DP
class Solution {
public:
    string longestPalindrome(string s) {
        int dp[s.size()][s.size()] = {0}, left = 0, right = 0, len = 0;
        for (int i = 0; i < s.size(); ++i) {
            for (int j = 0; j < i; ++j) {
                dp[j][i] = (s[i] == s[j] && (i - j < 2 || dp[j + 1][i - 1]));
                if (dp[j][i] && len < i - j + 1) {
                    len = i - j + 1;
                    left = j;
                    right = i;
                }
            }
            dp[i][i] = 1;
        }
        return s.substr(left, right - left + 1);
    }
};

// Manacher's Algorithm
class Solution {
public:
    string longestPalindrome(string s) {
        string t ="$#";
        for (int i = 0; i < s.size(); ++i) {
            t += s[i];
            t += '#';
        }
        int p[t.size()] = {0}, id = 0, mx = 0, resId = 0, resMx = 0;
        for (int i = 0; i < t.size(); ++i) {
            p[i] = mx > i ? min(p[2 * id - i], mx - i) : 1;
            while (t[i + p[i]] == t[i - p[i]]) ++p[i];
            if (mx < i + p[i]) {
                mx = i + p[i];
                id = i;
            }
            if (resMx < p[i]) {
                resMx = p[i];
                resId = i;
            }
        }
        return s.substr((resId - resMx) / 2, resMx - 1);
    }
};
\end{lstlisting}

\section{Longest Palindromic Subsequence (M)}
Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000. \\

Example:\\
Input: 'bbbab', Output: 4\\

Python:
\lstset{language=python}
\begin{lstlisting}
import numpy as np
class Solution(object):
    def longestPalindromeSubseq(self, s):
        """
        :type s: str
        :rtype: int
        """
        n = len(s)
        dp = np.zeros(shape=(n, n))
        for i in range(n-1, -1, -1):
            dp[i][i] = 1
            for j in range(i+1, n, 1):
                if s[i] == s[j]:
                    dp[i][j] = dp[i+1][j-1] + 2
                else: 
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])
        return int(dp[0][n-1])
\end{lstlisting}
\lstset{language=C++}

\section{Palindrome Permutation (E)}
Given a string, determine if a permutation of the string could form a palindrome.\\

For example, "code" $->$ False, "aab" $->$ True, "carerac" $->$ True.\\

\begin{lstlisting}
// 1. Hashtable
class Solution {
public:
    bool canPermutePalindrome(string s) {
        unordered_map<char, int> m;
        int cnt = 0;
        for (auto a : s) ++m[a];
        for (auto it : m) {
            if (it.second % 2 == 1)
                ++cnt;
        }
        return cnt == 0 || ((cnt == 1) && (s.size() % 2 == 1));
    }
};

// 2. Set
class Solution {
public:
    bool canPermutePalindrome(string s) {
        set<char> t;
        for (auto a : s) {
            if (t.find(a) == t.end()) t.insert(a);
            else t.erase(a);
        }
        return t.empty() || t.size() == 1;
    }
};

// 3. Bitset
class Solution {
public:
    bool canPermutePalindrome(string s) {
        bitset<256> b;
        for (auto a : s) {
            b.flip(a);
        }
        return b.count() < 2;
    }
};
\end{lstlisting}


\section{Palindrome Permutation II (M)}
Given a string s, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form.\\

For example:\\
Given s =``aabb", return [``abba", ``baab"].\\
Given s = ``abc", return [].\\

\begin{lstlisting}
class Solution {
public:
    vector<string> generatePalindromes(string s) {
        vector<string> res;
        unordered_map<char, int> m;
        string t = "", mid = "";
        for (auto a : s) ++m[a];
        for (auto it : m) {
            if (it.second % 2 == 1) 
                mid += it.first;
            t += string(it.second / 2, it.first);   // store the first half of string
            if (mid.size() > 1)                     // if the string is palindrome, mid size can only be 1
                return res;
        }
        permute(t, 0, mid, res);
        return res;
    }
    
    void permute(string &t, int start, string mid, vector<string> &res) {
        // palindrome permutation = permutation of the first half string 
        //                          + the only char if exists
        //                          + reverse of the permutation of the first half string
        if (start >= t.size()) {
            res.push_back(t + mid + string(t.rbegin(), t.rend()));
        } 
        // permutation
        for (int i = start; i < t.size(); ++i) {
            if (i != start && t[i] == t[start]) continue;
            swap(t[i], t[start]);
            permute(t, start + 1, mid, res);
            swap(t[i], t[start]);
        }
    }
};
\end{lstlisting}


\section{Palindrome Partitioning (M)}
Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\\

For example, given s = "aab",
Return
[
  ["aa","b"],
  ["a","a","b"]
]\\

\begin{lstlisting}
class Solution {
public:
    vector<vector<string>> partition(string s) {
        vector<vector<string>> res;
        vector<string> out;
        partitionDFS(s, 0, out, res);
        return res;
    }
    void partitionDFS(string s, int pos, vector<string> &out, vector<vector<string>> &res) {
        if (pos == s.size()) {
            res.push_back(out);
            return;
        }
        for (int i = pos; i < s.size(); ++i) {
            if (isPalindrome(s, pos, i)) {
                // substr(pos, len): substr starts at pos and spans len chars
                out.push_back(s.substr(pos, i - pos + 1));
                partitionDFS(s, i + 1, out, res);
                out.pop_back();
            }
        }
    }
    bool isPalindrome(string s, int start, int end) {
        while (start < end) {
            if (s[start] != s[end]) return false;
            ++start;
            --end;
        }
        return true;
    }
};
\end{lstlisting}


\section{Palindrome Partitioning II (H)}
Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. \\

For example, given s = "aab",
Return 1 since the palindrome partitioning ["aa","b"] could be produced using 1 cut. \\

\begin{lstlisting}
class Solution {
public:
    int minCut(string s) {
        int len = s.size();
        bool P[len][len];
        int dp[len + 1];
        for (int i = 0; i <= len; ++i) {
            dp[i] = len - i - 1;
        }
        for (int i = 0; i < len; ++i) {
            for (int j = 0; j < len; ++j) {
                P[i][j] = false;
            }
        }
        for (int i = len - 1; i >= 0; --i) {
            for (int j = i; j < len; ++j) {
                if (s[i] == s[j] && (j - i <= 1 || P[i + 1][j - 1])) {
                    P[i][j] = true;
                    dp[i] = min(dp[i], dp[j + 1] + 1);
                }
            }
        }
        return dp[0];
    }
};
\end{lstlisting}


\section{Longest Substring Without Repeating Characters (M)}
Given a string, find the length of the longest substring without repeating characters.\\

Examples:\\
Given "abcabcbb", the answer is "abc", which the length is 3.\\
Given "bbbbb", the answer is "b", with the length of 1.\\
Given "pwwkew", the answer is "wke", with the length of 3. Note that the answer must be a substring, "pwke" is a subsequence and not a substring.\\

Python:
\lstset{language=python}
\begin{lstlisting}
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        res = 0
        left = -1
        n = len(s)
        str_hash = {}
        for i in range(n):
            if s[i] in str_hash.keys() and str_hash[s[i]] > left:
                left = str_hash[s[i]]
            str_hash[s[i]] = i
            res = max(res, i - left)
        return res
\end{lstlisting}

C++:
\lstset{language=C++}
\begin{lstlisting}
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // left is the start position of each substring
        int m[256] = {0}, res = 0, left = 0;
        for (int i = 0; i < s.size(); ++i) {
            if (m[s[i]] == 0 || m[s[i]] < left) {
                res = max(res, i - left + 1);
            } else {
                left = m[s[i]]; // update left if repeat chars is found
            }
            m[s[i]] = i + 1;
        }
        return res;
    }
};

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector<int> m(256, -1);
        int res = 0, left = -1;
        for (int i = 0; i < s.size(); ++i) {
            left = max(left, m[s[i]]);
            m[s[i]] = i;
            res = max(res, i - left);
        }
        return res;
    }
};

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        set<char> t;
        int res = 0, left = 0, right = 0;
        while (right < s.size()) {
            if (t.find(s[right]) == t.end()) {
                t.insert(s[right++]);
                res = max(res, (int)t.size());
            }  else {
                t.erase(s[left++]);
            }
        }
        return res;
    }
};
\end{lstlisting}


\section{Longest Substring with At Least K Repeating Characters (M)}
Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.

Example 1:\\
Input:
s = "aaabb", k = 3
Output:
3\\
The longest substring is "aaa", as 'a' is repeated 3 times.\\

Example 2:\\
Input:
s = "ababbc", k = 2
Output:
5\\
The longest substring is "ababb", as 'a' is repeated 2 times and 'b' is repeated 3 times.\\

\begin{lstlisting}
class Solution {
public:
    int longestSubstring(string s, int k) {
        int n = s.size(), max_idx = 0, res = 0;
        int m[128] = {0};
        bool ok = true;
        for (char c : s) ++m[c];
        for (int i = 0; i < n; ++i) {
            if (m[s[i]] < k) {
                res = max(res, longestSubstring(s.substr(max_idx, i - max_idx), k));
                ok = false;
                max_idx = i + 1;
            }
        }
        return ok ? n : max(res, longestSubstring(s.substr(max_idx, n - max_idx), k));
    }
};

class Solution {
public:
    int longestSubstring(string s, int k) {
        int res = 0, i = 0, n = s.size();
        while (i + k < n) {
            int m[26] = {0}, mask = 0, max_idx = i;
            for (int j = i; j < n; ++j) {
                int t = s[j] - 'a';
                ++m[t];
                if (m[t] < k) mask |= (1 << t);
                else mask &= (~(1 << t));
                if (mask == 0) {
                    res = max(res, j - i + 1);
                    max_idx = j;
                }
            }
            i = max_idx + 1;
        }
        return res;
    }
};
\end{lstlisting}


\section{Longest Substring with At Most Two Distinct Characters (H)}
Given a string S, find the length of the longest substring T that contains at most two distinct characters.\\
For example,
Given S = ``eceba",
T is ``ece" which its length is 3. \\

\begin{lstlisting}
class Solution {
public:
    int lengthOfLongestSubstringTwoDistinct(string s) {
        int res = 0, left = 0;
        unordered_map<char, int> m;
        for (int i = 0; i < s.size(); ++i) {
            ++m[s[i]];
            while (m.size() > 2) {
                if (--m[s[left]] == 0) m.erase(s[left]);
                ++left;
            }
            res = max(res, i - left + 1);
        }
        return res;
    }
};

class Solution {
public:
    int lengthOfLongestSubstringTwoDistinct(string s) {
        int res = 0, left = 0;
        unordered_map<char, int> m;
        for (int i = 0; i < s.size(); ++i) {
            m[s[i]] = i;
            while (m.size() > 2) {
                if (m[s[left]] == left) m.erase(s[left]);
                ++left;
            }
            res = max(res, i - left + 1);
        }
        return res;
    }
};
\end{lstlisting}


\section{Longest Substring with At Most K Distinct Characters (H)}
Given a string, find the length of the longest substring T that contains at most k distinct characters.\\

For example, Given s = ``eceba" and k = 2, T is ``ece" which its length is 3.\\

\begin{lstlisting}
class Solution {
public:
    int lengthOfLongestSubstringKDistinct(string s, int k) {
        int res = 0, left = 0;
        unordered_map<char, int> m;
        for (int i = 0; i < s.size(); ++i) {
            ++m[s[i]];
            while (m.size() > k) {
                if (--m[s[left]] == 0) m.erase(s[left]);
                ++left;
            }
            res = max(res, i - left + 1);
        }
        return res;
    }
};

class Solution {
public:
    int lengthOfLongestSubstringKDistinct(string s, int k) {
        int res = 0, left = 0;
        unordered_map<char, int> m;
        for (int i = 0; i < s.size(); ++i) {
            m[s[i]] = i;
            while (m.size() > k) {
                if (m[s[left]] == left) m.erase(s[left]);
                ++left;
            }
            res = max(res, i - left + 1);
        }
        return res;
    }
};
\end{lstlisting}

\section{Minimum Window Substring (H)}
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\\

Example:\\
Input: S = "ADOBECODEBANC", T = "ABC"\\
Output: "BANC"\\

Note:\\
    If there is no such window in S that covers all characters in T, return the empty string "".\\
    If there is such window, you are guaranteed that there will always be only one unique minimum window in S.\\

\begin{lstlisting}
class Solution(object):
    def minWindow(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: str
        """
        res = ''
        letter_cnt = {}
        left, cnt = 0, 0
        min_len = float('inf')
        for c in t:
            if c in letter_cnt: letter_cnt[c] += 1
            else: letter_cnt[c] = 1
        for i in range(len(s)):
            # find the substring that contains all chars in t
            if s[i] in letter_cnt:
                letter_cnt[s[i]] -= 1
                if letter_cnt[s[i]] >= 0: cnt += 1
            # if cnt matches the length of t, then we find the substring
            while cnt == len(t):
                # update the substring min_len and res
                # the current sliding window is from left to i
                if min_len > i - left + 1:
                    min_len = i - left + 1
                    res = s[left : i + 1]
                # check if s[left] is the char that is in t
                # if it is, add the hash value back and reduce cnt
                if s[left] in letter_cnt:
                    letter_cnt[s[left]] += 1
                    if letter_cnt[s[left]] > 0: cnt -= 1
                # move left window
                left += 1
        return res
\end{lstlisting}

\section{Isomorphic Strings (E)}
Given two strings s and t, determine if they are isomorphic. \\

Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.\\

For example,\\
Given ``egg", ``add", return true.\\
Given ``foo", ``bar", return false.\\
Given ``paper", ``title", return true.\\

\begin{lstlisting}
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        if (s.size() != t.size())   return false;
            
        int m1[128] = {0};
        int m2[128] = {0};
        for (int i = 0; i < s.size(); ++i) {
            if (m1[s[i]] != m2[t[i]])
                return false;
            m1[s[i]] = i+1;
            m2[t[i]] = i+1;
        }
        return true;
    }
};

// intuitive solution  
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        if (s.size()== 0)   return true;
        
        unordered_map<char, char> map1;
        unordered_map<char, char> map2;
        map1.insert(make_pair(s[0], t[0]));
        map2.insert(make_pair(t[0], s[0]));
        
        for (int i = 1; i< s.size(); i++){
            if (map1.find(s[i])!=map1.end()){
                if (t[i] != map1.at(s[i])) {
                    return false;
                }
            }
            
            if (map2.find(t[i])!=map2.end()){
                
                if (s[i] != map2.at(t[i])) {
                    return false;
                }
            }
            
            else {
                map1.insert(make_pair(s[i],t[i]));
                map2.insert(make_pair(t[i],s[i]));
            }
        }
        return true;
    }
};
\end{lstlisting}


\section{Word Pattern (E)}
Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. \\

Examples:\\
    pattern = ``abba", str = ``dog cat cat dog" should return true.\\
    pattern = ``abba", str = ``dog cat cat fish" should return false.\\
    pattern = ``aaaa", str = ``dog cat cat dog" should return false.\\
    pattern = ``abba", str = ``dog dog dog dog" should return false.\\

\begin{lstlisting}
class Solution {
public:
    bool wordPattern(string pattern, string str) {
        unordered_map<char, int> p;
        unordered_map<string, int> w;
        istringstream in(str);              // read each word from str to in
        int i = 0;
        
        for (string word; in >> word; ++i) {
            if (p.find(pattern[i]) != p.end() || w.find(word) != w.end()) {
                if (p[pattern[i]] != w[word]) return false;
            } else {
                p[pattern[i]] = w[word] = i + 1;
            }
        }
        return i == pattern.size();
    }
};
\end{lstlisting}


\section{Word Pattern II (H)}
Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty substring in str.\\

Examples:\\
    pattern = "abab", str = "redblueredblue" should return true.\\
    pattern = "aaaa", str = "asdasdasdasd" should return true.\\
    pattern = "aabb", str = "xyzabcxzyabc" should return false.\\

Notes: You may assume both pattern and str contains only lowercase letters.\\

\begin{lstlisting}
class Solution {
public:
    bool wordPatternMatch(string pattern, string str) {
        unordered_map<char, string> m;
        set<string> s;
        return helper(pattern, 0, str, 0, m, s);
    }
    bool helper(string pattern, int p, string str, int r, unordered_map<char, string> &m, set<string> &s) {
        if (p == pattern.size() && r == str.size()) return true;
        if (p == pattern.size() || r == str.size()) return false;
        char c = pattern[p];
        for (int i = r; i < str.size(); ++i) {
            string t = str.substr(r, i - r + 1);
            if (m.count(c) && m[c] == t) {
                if (helper(pattern, p + 1, str, i + 1, m, s)) return true;
            } else if (!m.count(c)) {
                if (s.count(t)) continue;
                m[c] = t;
                s.insert(t);
                if (helper(pattern, p + 1, str, i + 1, m, s)) return true;
                m.erase(c);
                s.erase(t);
            }
        }
        return false;
    }
};
\end{lstlisting}


\section{Word Break (M)}
Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\\

For example, given
s = "leetcode",
dict = ["leet", "code"].
Return true because "leetcode" can be segmented as "leet code". \\

\begin{lstlisting}
class Solution(object):
    def wordBreak(self, s, wordDict):
        """
        :type s: str
        :type wordDict: List[str]
        :rtype: bool
        """
        dp = [False for i in range(len(s)+1)]
        dp[0] = True
        for i in range(len(dp)):
            for j in range(i):
                # if s[0:j] can be segmented and s[j:i] is in wordDict,
                # then s[0:i] can be segmented
                if dp[j] and s[j:i] in wordDict:
                    dp[i] = True
                    break
        return dp[-1]
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    bool wordBreak(string s, unordered_set<string> &wordDict) {
        int len = s.size();
        vector<bool> res(len + 1, false);
        res[0] = true;
        for (int i = 0; i < len + 1; ++i) {
            for (int j = 0; j < i; ++j) {
                if (res[j] && wordDict.find(s.substr(j, i-j)) != wordDict.end()) {
                    res[i] = true;
                    break;
                }
            }
        }
        return res[len];
    }
};
\end{lstlisting}


\section{Word Break II (H)}
Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.

For example, given
s = "catsanddog",
dict = ["cat", "cats", "and", "sand", "dog"].
A solution is ["cats and dog", "cat sand dog"]. \\

\begin{lstlisting}
class Solution {
public:
    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {
        vector<string> res;
        string out;
        vector<bool> possible(s.size() + 1, true);
        wordBreakDFS(s, wordDict, 0, possible, out, res);
        return res;
    }
    void wordBreakDFS(string &s, unordered_set<string> &wordDict, int start, vector<bool> &possible, string &out, vector<string> &res) {
        if (start == s.size()) {
            res.push_back(out.substr(0, out.size() - 1));
            return;
        }
        for (int i = start; i < s.size(); ++i) {
            string word = s.substr(start, i - start + 1);
            if (wordDict.find(word) != wordDict.end() && possible[i + 1]) {
                out.append(word).append(" ");
                int oldSize = res.size();
                wordBreakDFS(s, wordDict, i + 1, possible, out, res);
                if (res.size() == oldSize) possible[i + 1] = false;
                out.resize(out.size() - word.size() - 1);
            }
        }
    }
};
\end{lstlisting}

\section{Shortest Word Distance (E)}
Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.\\

For example,\\
Assume that words = [``practice", ``makes", ``perfect", ``coding", ``makes"].\\
Given word1 = ``coding", word2 = ``practice", return 3.\\
Given word1 = ``makes", word2 = ``coding", return 1.\\

Note: You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.\\

\begin{lstlisting}
class Solution {
public:
    int shortestDistance(vector<string>& words, string word1, string word2) {
        int p1 = -1, p2 = -1, res = INT_MAX;
        for (int i = 0; i < words.size(); ++i) {
            if (words[i] == word1)  p1 = i;
            if (words[i] == word2)  p2 = i;
            if (p1 != -1 && p2 != -1)
                res = min(res, abs(p1 - p2));
        }
        return res;
    }
};

class Solution {
public:
    int shortestDistance(vector<string>& words, string word1, string word2) {
        int idx = -1, res = INT_MAX;
        for (int i = 0; i < words.size(); ++i) {
            if (words[i] == word1 || words[i] == word2)  {
                if (idx != -1 && words[idx] != words[i]) {
                    res = min(res, i - idx)
                }
                idx = i;
            }
        }
        return res;
    }
};
\end{lstlisting}


\section{Shortest Word Distance II (M)}
This is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it? Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.\\

For example,\\
Assume that words = [``practice", ``makes", ``perfect", ``coding", ``makes"].\\
Given word1 = ``coding", word2 = ``practice", return 3.\\
Given word1 = ``makes", word2 = ``coding", return 1.\\

Note: You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.\\

\begin{lstlisting}
// 1. O(MN) solution
class WordDistance {
public:
    WordDistance(vector<string> &words) {
        for (int i = 0; i < words.size(); ++i) {
            m[words[i]].push_back(i);
        }
    }
    
    int shortestDistance(string word1, string word2) {
        int res = INT_MAX;
        for (int i = 0; i < m[word1].size(); ++i) {
            for (int j = 0; j < m[word2].size(); ++j) {
                res = min(res, abs(m[word1][i] - m[word2][j]));
            }
        }
        return res;
    }

private:
    unordered_map<string, vector<int>> m;
};

// 2. O(M+N) solution
class WordDistance {
public:
    WordDistance(vector<string> &words) {
        for (int i = 0; i < words.size(); ++i) {
            m[words[i]].push_back(i);
        }
    }
    
    int shortestDistance(string word1, string word2) {
        int i = 0, j = 0, res = INT_MAX;
        while (i < m[word1].size() && j < m[word2].size()) {
            res = min(res, abs(m[word1][i] - m[word2][j]));
            m[word1][i] < m[word2][j] ? ++i : ++j;    
        }
        return res;
    }

private:
    unordered_map<string, vector<int>> m;
};
\end{lstlisting}


\section{Shortest Word Distance III (M)}
This is a follow up of Shortest Word Distance. The only difference is now word1 could be the same as word2. Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list. In this time, word1 and word2 may be the same and they represent two individual words in the list.

For example,\\
Assume that words = [``practice", ``makes", ``perfect", ``coding", ``makes"].\\
Given word1 = ``makes", word2 = ``coding", return 1.\\
Given word1 = ``makes", word2 = ``makes", return 3.\\

Note:
You may assume word1 and word2 are both in the list. 

\begin{lstlisting}
class Solution {
public:
    int shortestWordDistance(vector<string>& words, string word1, string word2) {
        int idx = -1, res = INT_MAX;
        for (int i = 0; i < words.size(); ++i) {
            if (words[i] == word1 || words[i] == word2) {
                if (idx != -1 && (word1 == word2 || words[i] != words[idx])) {
                    res = min(res, i - idx);
                }
                idx = i;
            }
        }
        return res;
    }
};
\end{lstlisting}


\section{Strobogrammatic Number (E)}
A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Write a function to determine if a number is strobogrammatic. The number is represented as a string.\\

For example, the numbers "69", "88", and "818" are all strobogrammatic.\\

\begin{lstlisting}
class Solution{
public:
    bool isStrobogrammatic(string num) {
        int l = 0, r = num.size() - 1;
        while (l <= r) {
            if (num[l] == num[r]) {
                if (num[l] != '1' || num[l] != '8' || num[l] != '0') {
                    return false;
                }
            } else {
                if ( (num[l] != '6' || num[r] != '9') && (num[l] != '9' || num[r] != '6') ) {
                    return false;
                }
            }
            ++l;
            --r;
        }
        return true;
    }
};
\end{lstlisting}


\section{Strobogrammatic Number II (M)}
A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Find all strobogrammatic numbers that are of length = n.\\

For example, Given n = 2, return ["11","69","88","96"].\\

Hint: Try to use recursion and notice that it should recurse with n - 2 instead of n - 1. \\

\begin{lstlisting}
class Solution {
public:
    vector<string> findStrobogrammatic(int n) {
        return find(n, n);
    }
    
    vector<string> find(int m, int n) {
        if (m == 0) return {""};
        if (m == 1) return {"0", "1", "8"};
        vector<string> t = find(m - 2, n), res;
        
        for (auto a : t) {
            // add 0 to both side of a if level m is not level n
            if (m != n) res.push_back("0" + a + "0"); 
            
            res.push_back("1" + a + "1");
            res.push_back("6" + a + "9");
            res.push_back("8" + a + "8");
            res.push_back("9" + a + "6");
        }
        
        return res;
    }
};
\end{lstlisting}


\section{Strobogrammatic Number III (M)}
A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Write a function to count the total strobogrammatic numbers that exist in the range of $low \leq num \leq high$. \\

For example,\\
Given low = "50", high = "100", return 3. Because 69, 88, and 96 are three strobogrammatic numbers. \\

Note: Because the range might be a large number, the low and high numbers are represented as string.\\

\begin{lstlisting}
class Solution {
public:
    int strobogrammaticInRange(string low, string high) {
        int res = 0;
        find(low, high, "", res);
        find(low, high, "0", res);
        find(low, high, "1", res);
        find(low, high, "8", res);
        return res;
    }
    void find(string low, string high, string w, int &res) {
        if (w.size() >= low.size() && w.size() <= high.size()) {
            if ((w.size() == low.size() && w.compare(low) < 0) || (w.size() == high.size() && w.compare(high) > 0)) {
                return;
            }
            if (!(w.size() > 1 && w[0] == '0')) ++res;
        }
        if (w.size() + 2 > high.size()) return;
        find(low, high, "0" + w + "0", res);
        find(low, high, "1" + w + "1", res);
        find(low, high, "6" + w + "9", res);
        find(low, high, "8" + w + "8", res);
        find(low, high, "9" + w + "6", res);
    }
};
\end{lstlisting}


\section{Unique Word Abbreviation (E)}
An abbreviation of a word follows the form $<first letter><number><last letter>$. Below are some examples of word abbreviations:\\

a) it                     $ -->$ it    (no abbreviation)\\

b) d|o|g                   $-->$ d1g\\

c) i|nternationalizatio|n  $-->$ i18n\\

d) l|ocalizatio|n          $-->$ l10n\\

Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word's abbreviation is unique if no other word from the dictionary has the same abbreviation.\\

Example: \\
Given dictionary = [ "deer", "door", "cake", "card" ]\\
isUnique("dear") $->$ false\\
isUnique("cart") $->$ true\\
isUnique("cane") $->$ false\\
isUnique("make") $->$ true\\

\begin{lstlisting}
class ValidWordAbbr {
public:
    ValidWordAbbr(vector<string> &dictionary) {
        for (auto a : dictionary) {
            // get the word abbreviation in dictionary
            string k = a.front() + to_string(a.size() - 2) + a.back(); 
            m[k].insert(a);
        }
    }
    
    // If this word (also this word's abbreviation) is not in the dictionary 
    // OR this word and only it's abbreviation in the dictionary,
    // we call a word's abbreviation unique.
    bool isUnique(string word) {
        // get the word abbreviation
        string k = word.front() + to_string(word.size() - 2) + word.back();
        return m[k].count(word) == m[k].size();
    }
    
private:
    unordered_map<string, set<string>> m;   // mapping the word abbr and the words
};
\end{lstlisting}


\section{Generalized Abbreviation (M)}
Write a function to generate the generalized abbreviations of a word.\\

Example: Given word = "word", return the following list (order does not matter):\\
$["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", \\
"1o2", "2r1", "3d", "w3", "4"]$ \\

\begin{lstlisting}
// 1. Iterative solution
class Solution {
public:
    vector<string> generateAbbreviations(string word) {
        vector<string> res;
        // Use binary bit to code word
        for (int i = 0; i < pow(2, word.size()); ++i) {
            string out = "";
            int cnt = 0, t = i;
            for (int j = 0; j < word.size(); ++j) {
                if (t & 1 == 1) { // If bit is 1, count it as a number
                    ++cnt;
                    if (j == word.size() - 1) {
                        out += to_string(cnt);
                    }
                } else { // If bit is 0, count it as a char
                    if (cnt != 0) { // If there is a number counted, output it
                        out += to_string(cnt);
                        cnt = 0;
                    }
                    out += word[j]; // Otherwise output char
                }
                t >>= 1; // Move to next bit
            }
            res.push_back(out);
        }
        return res;
    }
};

// 2. Recursive solution
class Solution {
public:
    vector<string> generateAbbreviations(string word) {
        vector<string> res{word};
        helper(word, 0, res);
        return res;
    }
    void helper(string word, int pos, vector<string> &res) {
        for (int i = pos; i < word.size(); ++i) {
            for (int j = 1; i + j <= word.size(); ++j) {
                string t = word.substr(0, i);
                t += to_string(j) + word.substr(i + j);
                res.push_back(t);
                helper(t, i + 1 + to_string(j).size(), res);
            }
        }
    }
};
\end{lstlisting}


\section{One Edit Distance (M)}
Given two strings S and T, determine if they are both one edit distance apart.\\

\begin{lstlisting}
# based on the definition of one edit distance
def isOneEditDistance(s, t):
	m, n = len(s), len(t)
	diff = abs(m - n)
	if diff >= 2: 
		return False
	elif diff == 1:
		for i in range( min(m,n) ):
			if s[i] != t[i]:
				if m > n: return s[i+1:] == t[i:]
				elif m < n: return s[i:] == t[i+1:]
	else:
		cnt = 0
		for i in range(n):
			if s[i] != t[i]:
				cnt += 1
		return cnt == 1

# compare each char in s and t
def isOneEditDistance(s, t):
	m, n = len(s), len(t)
	for i in range( min(m,n) ):
		if s[i] != t[i]:
			if m == n: return s[i+1:] == t[i+1:]
			elif m > n: return s[i+1:] == t[i:]
			else: return s[i:] == t[i+1:]
	# if all s[i] and t[i] are the same in above loop,
	# then the abs diff between s and t must be 1 when their edit distance is one
	return abs(m-n) == 1
\end{lstlisting}

\begin{lstlisting}
class Solution {
public:
    bool isOneEditDistance(string s, string t) {
        for (int i = 0; i < min(s.size(), t.size()); ++i) {
             // if the only difference is between s[i] and t[i]
             // then the left substring in both s and t should be exactly the same
            if (s[i] != t[i]) {
                if (s.size() == t.size()) return s.substr(i + 1) == t.substr(i + 1);
                else if (s.size() < t.size()) return s.substr(i) == t.substr(i + 1);
                else return s.substr(i + 1) == t.substr(i);
            }
        }
        // if no difference is found, 
        // s and t are vaild if they have at least one difference in size
        return abs(s.size() - t.size()) == 1;
    }
};
\end{lstlisting}


\section{Edit Distance (H)}
Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)\\

You have the following 3 operations permitted on a word:\\
a) Insert a character\\
b) Delete a character\\
c) Replace a character\\

\begin{lstlisting}
/** 1. dp[i][0] = i;
 *  2. dp[0][j] = j;
 *  3. dp[i][j] = dp[i - 1][j - 1], if word1[i - 1] = word2[j - 1];
 *  4. dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1), otherwise.
 * 
 *  Replace word1[i - 1] by word2[j - 1] (dp[i][j] = dp[i - 1][j - 1] + 1 (for replacement));
 *  Delete word1[i - 1] and word1[0..i - 2] = word2[0..j - 1] (dp[i][j] = dp[i - 1][j] + 1 (for deletion));
 *  Insert word2[j - 1] to word1[0..i - 1] and word1[0..i - 1] + word2[j - 1] = word2[0..j - 1] (dp[i][j] = dp[i][j - 1] + 1 (for insertion)).
 *  
 * For deletion, we are actually converting word1[0..i - 2] to word2[0..j - 1], which costs dp[i - 1][j], and then deleting the word1[i - 1], which costs 1. The case is similar for insertion. 
 */
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n1 = word1.size(), n2 = word2.size();
        int dp[n1 + 1][n2 + 1];
        for (int i = 0; i <= n1; ++i) dp[i][0] = i;
        for (int i = 0; i <= n2; ++i) dp[0][i] = i;
        for (int i = 1; i <= n1; ++i) {
            for (int j = 1; j <= n2; ++j) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;
                }
            }
        }
        return dp[n1][n2];
    }
};
\end{lstlisting}

\section{String Compression (E)}
Given an array of characters, compress it in-place.

The length after compression must always be smaller than or equal to the original array.

Every element of the array should be a character (not int) of length 1.

After you are done modifying the input array in-place, return the new length of the array.

\begin{lstlisting}
class Solution(object):
    def compress(self, chars):
        """
        :type chars: List[str]
        :rtype: int
        """
        cur = 0
        n = len(chars)
        i, j = 0, 0
        while i < n:
            while j < n and chars[i] == chars[j]:
                j += 1
            chars[cur] = chars[i]
            cur += 1
            # j-i is the length of each compressed char
            if j - i == 1: 
                i = j
                continue
            for c in str(j-i):
                chars[cur] = c
                cur += 1
            i = j
        return cur
\end{lstlisting}

\section{Encode and Decode Strings (M)}
Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings. Implement the encode and decode methods.\\

Note:\\
    The string may contain any possible characters out of 256 valid ascii characters. Your algorithm should be generalized enough to work on any possible characters.\\
    Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.\\
    Do not rely on any library method such as eval or serialize methods. You should implement your own encode/decode algorithm.\\

\begin{lstlisting}
class Codec {
public:
    // Encodes a list of strings to a single string.
    // e.g. "a", "ab", "abc" -> 1/a2/ab3/abc
    string encode(vector<string>& strs) {
        string res = "";
        for (auto a : strs) {
            res.append(to_string(a.size())).append("/").append(a);
        }
        return res;
    }
    // Decodes a single string to a list of strings.
    vector<string> decode(string s) {
        vector<string> res;
        int i = 0;
        while (i < s.size()) {
            auto found = s.find("/", i);
            int len = atoi(s.substr(i, found).c_str());
            res.push_back(s.substr(found + 1, len));
            i = found + len + 1;
        }
        return res;
    }
};
\end{lstlisting}


\section{Decode String (M)}
Given an encoded string, return it's decoded string. The encoding rule is: k[encoded-string], where the encoded-string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\\

You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\\

Examples:\\
s = "3[a]2[bc]", return "aaabcbc".\\
s = "3[a2[c]]", return "accaccacc".\\
s = "2[abc]3[cd]ef", return "abcabccdcdcdef".\\

\begin{lstlisting}
class Solution {
public:
    string decodeString(string s) {
        int i = 0;
        return decode(s, i);
    }
    string decode(string s, int &i) {
        string res = "";
        int n = s.size();
        // check each substring until meet ']' or the end of s
        while (i < n && s[i] != ']') { 
            if (s[i] < '0' || s[i] > '9') { // if s[i] is char, store it to res
                res += s[i++];
            } else {
                int cnt = 0;
                // get the value of k
                while (i < n && s[i] >= '0' && s[i] <= '9') {
                    cnt = cnt * 10 + s[i++] - '0';
                }
                ++i; // skip the next [
                string t = decode(s, i); // get the substring
                ++i; // skip the next ]
                while (cnt-- > 0) res += t; // write the substring by k times
            }
        }
        return res;
    }
};
\end{lstlisting}


\section{Read N Characters Given Read4 (E)}
The API: int read4(char *buf) reads 4 characters at a time from a file. The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file. By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.\\

Note:The read function will only be called once for each test case.\\

\begin{lstlisting}
int read4(char *buf);

class Solution {
public:
    int read(char *buf, int n) {
        int res = 0;
        for (int i = 0; i <= n / 4; ++i) {
            int cur = read4(buf + res);
            if (cur == 0) break;
            res += cur;
        }
        return min(res, n);
    }
};
\end{lstlisting}


\section{Read N Characters Given Read4 II (H)}
The API: int read4(char *buf) reads 4 characters at a time from a file. The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file. By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.\\

Note: The read function may be called multiple times. \\

\begin{lstlisting}
class Solution {
public:
    int read(char *buf, int n) {
        for (int i = 0; i < n; ++i) {
            if (readPos == writePos) {
                writePos = read4(buff);
                readPos = 0;
                if (writePos == 0) return i;
            }
            buf[i] = buff[readPos++];
        }
        return n;
    }
private:
    int readPos = 0, writePos = 0;
    char buff[4];
};
\end{lstlisting}

\section{Remove Comments (M)}
Given a C++ program, remove comments from it. The program source is an array where source[i] is the i-th line of the source code. This represents the result of splitting the original source code string by the newline character.\\

In C++, there are two types of comments, line comments, and block comments.\\

The string // denotes a line comment, which represents that it and rest of the characters to the right of it in the same line should be ignored.\\

The string /* denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of */ should be ignored. (Here, occurrences happen in reading order: line by line from left to right.) To be clear, the string /*/ does not yet end the block comment, as the ending would be overlapping the beginning.\\

The first effective comment takes precedence over others: if the string // occurs in a block comment, it is ignored. Similarly, if the string /* occurs in a line or block comment, it is also ignored.\\

If a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.\\

There will be no control characters, single quote, or double quote characters. For example, source = "string s = "/* Not a comment. */";" will not be a test case. (Also, nothing else such as defines or macros will interfere with the comments.)\\

It is guaranteed that every open block comment will eventually be closed, so /* outside of a line or block comment always starts a new comment.\\

Finally, implicit newline characters can be deleted by block comments. Please see the examples below for details.\\

After removing the comments from the source code, return the source code in the same format.\\

\begin{lstlisting}
class Solution(object):
    def removeComments(self, source):
        """
        :type source: List[str]
        :rtype: List[str]
        """
        in_block = False
        res = []
        for line in source:
            i = 0
            if not in_block:
                newline = []
            while i < len(line):
                if line[i:i+2] == '/*' and not in_block:
                    in_block = True
                    i += 1
                elif line[i:i+2] == '*/' and in_block:
                    in_block = False
                    i += 1
                elif line[i:i+2] == '//' and not in_block:
                    break
                elif not in_block:
                    newline.append(line[i])
                i += 1
            if newline and not in_block:
                res.append("".join(newline))
        return res
\end{lstlisting}

\section{Maximum Swap (M)}
 Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.\\

Example 1:\\
Input: 2736\\
Output: 7236\\
Explanation: Swap the number 2 and the number 7.\\

Example 2:\\
Input: 9973\\
Output: 9973\\
Explanation: No swap.\\

\begin{lstlisting}
# O(N): every digit is considered at most once
class Solution(object):
    def maximumSwap(self, num):
        """
        :type num: int
        :rtype: int
        """
        str_num = str(num)
        n = len(str_num)
        dict_num_idx = {}
        for i in range(n):
            dict_num_idx[ord(str_num[i]) - ord('0')] = i
        # when scanning the number from left to right, 
        # if there is a larger digit in the future, 
        # we will swap it with the largest such digit; 
        # if there are multiple such digits, 
        # we will swap it with the one that occurs the latest.        
        for i in range(n):
            for j in range(9, ord(str_num[i]) - ord('0'), -1):
                if j in dict_num_idx and dict_num_idx[j] > i:
                    str_num = self.swap(str_num, i, dict_num_idx[j])
                    return int(str_num)
        return num
    # a string has to be converted to a list for swapping
    def swap(self, string, i, j):
        l = list(string)
        l[i], l[j] = l[j], l[i]
        return ''.join(l)
\end{lstlisting}

\section{Verifying an Alien Dictionary (E)}
In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.

Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language.

Example 1:

Input: words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
Output: true
Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted.

Example 2:

Input: words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
Output: false
Explanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.

Example 3:

Input: words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"
Output: false
Explanation: The first three characters "app" match, and the second string is shorter (in size.) According to lexicographical rules "apple" > "app", because 'l' > 'None', where 'None' is defined as the blank character which is less than any other character (More info).

Note:
    1 <= words.length <= 100
    1 <= words[i].length <= 20
    order.length == 26
    All characters in words[i] and order are english lowercase letters.

\begin{lstlisting}
class Solution(object):
    def isAlienSorted(self, words, order):
        """
        :type words: List[str]
        :type order: str
        :rtype: bool
        """
        order_index = {c: i for i, c in enumerate(order)}

        for i in xrange(len(words) - 1):
            word1 = words[i]
            word2 = words[i+1]

            # Find the first difference between word1[k] and word2[k]
            for k in xrange(min(len(word1), len(word2))):
                if word1[k] != word2[k]:
                    # If they compare badly, it's not sorted
                    if order_index[word1[k]] > order_index[word2[k]]:
                        return False
                    break
                else:
                    # If we didn't find any difference between word1[k] and word2[k], 
                    # the words are like ("app", "apple")
                    if len(word1) > len(word2):
                        return False
        return True
\end{lstlisting}

